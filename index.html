<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Upload - Reset Clears Data</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <style>
        /* Apply Inter font globally */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Hide the default file input */
        #imageUpload {
            display: none;
        }

        /* Style for the image preview container */
        .instagram-card {
            max-width: 480px;
            /* Typical max-width */
            width: 100%;
        }

        /* Container for image and canvas */
        .image-display-container {
            position: relative;
            background-color: #f3f4f6;
            /* bg-gray-100 */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            aspect-ratio: 1 / 1;
            /* Maintain aspect ratio */
            max-height: 600px;
        }

        /* Ensure image fits well */
        .instagram-card img#imagePreview {
            display: block;
            max-width: 100%;
            max-height: 100%;
            height: auto;
            width: auto;
            object-fit: contain;
        }

        /* Canvas overlay */
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            /* Adjusted by JS */
            height: 100%;
            /* Adjusted by JS */
            cursor: default;
            /* Default cursor */
        }

        #overlayCanvas.dragging,
        #overlayCanvas.point-hover {
            cursor: grab;
            /* Cursor when hovering/dragging pose point */
        }

        /* Material Symbols styling */
        .material-symbols-outlined {
            vertical-align: middle;
            font-size: 24px;
            cursor: pointer;
            transition: color 0.2s ease;
            /* Smooth color transition */
        }

        /* Style for active icons */
        .material-symbols-outlined.active {
            color: #3b82f6;
            /* Blue color when active */
        }

        /* Style for disabled icons */
        .material-symbols-outlined.disabled {
            cursor: not-allowed;
            opacity: 0.5;
            color: #6b7280;
            /* Gray color when disabled */
        }

        .material-symbols-outlined.disabled.active {
            /* Ensure active style doesn't override disabled */
            color: #6b7280;
            opacity: 0.5;
        }

        /* Comments area styling */
        #commentArea {
            max-height: 100px;
            overflow-y: auto;
            padding-top: 0.5rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            color: #1f2937;
        }

        #commentArea p {
            margin-bottom: 0.375rem;
            word-break: break-word;
        }

        #commentArea .comment-username {
            font-weight: 600;
            margin-right: 0.375rem;
            color: #111827;
        }

        #commentArea .comment-error {
            color: #ef4444;
        }

        #commentArea .comment-success {
            color: #22c55e;
        }

        #commentArea .comment-info {
            color: #374151;
        }

        /* Modal Styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 1.5rem 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90%;
            width: 350px;
            text-align: center;
        }

        .modal-title {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #1f2937;
        }

        .modal-body {
            margin-bottom: 1.5rem;
            color: #4b5563;
        }

        .modal-actions button {
            margin: 0 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        .modal-actions button.select-face-btn {
            background-color: #3b82f6;
            color: white;
        }

        .modal-actions button.select-face-btn:hover {
            background-color: #2563eb;
        }

        .modal-actions button.cancel-btn {
            background-color: #e5e7eb;
            color: #374151;
        }

        .modal-actions button.cancel-btn:hover {
            background-color: #d1d5db;
        }
    </style>
</head>

<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto flex flex-col items-center">
        <label for="imageUpload"
            class="cursor-pointer inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out mb-6 w-full sm:w-auto">
            Upload Image
        </label>
        <input type="file" id="imageUpload" accept="image/*">

        <div id="imagePreviewContainer"
            class="instagram-card bg-white border border-gray-300 rounded-lg shadow-md overflow-hidden hidden mx-auto">
            <div class="p-3 border-b border-gray-200 flex items-center space-x-3">
                <div class="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center">
                    <span class="material-symbols-outlined text-gray-500 text-lg">person</span>
                </div>
                <span class="font-semibold text-sm text-gray-800">sketchit</span>
            </div>

            <div class="image-display-container">
                <img id="imagePreview" src="#" alt="Image Preview" class="block">
                <canvas id="overlayCanvas"></canvas>
                <div id="placeholderText" class="text-center text-gray-500 p-10 hidden">Select an image to preview</div>
            </div>

            <div class="p-3 border-t border-gray-200 space-y-3">
                <div class="flex space-x-4 items-center">
                    <span id="iconFace" class="material-symbols-outlined text-gray-700 hover:text-gray-900 disabled"
                        title="Toggle Face Landmarks">face</span>
                    <span id="iconPose" class="material-symbols-outlined text-gray-700 hover:text-gray-900 disabled"
                        title="Toggle Pose Landmarks">accessibility_new</span>
                    <span id="iconRestart" class="material-symbols-outlined text-gray-700 hover:text-gray-900"
                        title="Clear All Overlays & Data">restart_alt</span>
                </div>
                <div id="commentArea">
                    <p class="comment-info"><span class="comment-username">System</span>Initializing MediaPipe...</p>
                </div>
            </div>
        </div>
    </div>

    <div id="faceSelectionModal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">Select Reference Face</h3>
            <p class="modal-body">Multiple faces detected. Please select the face to use for grid drawing.</p>
            <div id="modalFaceButtons" class="modal-actions flex flex-wrap justify-center gap-2 mb-4"></div>
            <div class="modal-actions">
                <button id="cancelModalButton" class="cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <script type="module">
        import {
            FaceLandmarker, PoseLandmarker,
            FilesetResolver, DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // --- DOM Elements ---
        const imageUpload = document.getElementById('imageUpload');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreview = document.getElementById('imagePreview');
        const placeholderText = document.getElementById('placeholderText');
        const commentArea = document.getElementById('commentArea');
        const iconFace = document.getElementById('iconFace');
        const iconPose = document.getElementById('iconPose');
        const iconRestart = document.getElementById('iconRestart');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const canvasCtx = overlayCanvas.getContext('2d');
        const faceSelectionModal = document.getElementById('faceSelectionModal');
        const modalFaceButtons = document.getElementById('modalFaceButtons');
        const cancelModalButton = document.getElementById('cancelModalButton');

        // --- MediaPipe Variables ---
        let faceLandmarker, poseLandmarker, drawingUtils, visionResolver = null;
        let isFaceLandmarkerInitialized = false, isPoseLandmarkerInitialized = false;
        let currentImageElement = null;
        let lastFaceDetections = null, lastPoseDetections = null; // Original normalized results

        // --- Draggable State ---
        let draggablePoseLandmarks = []; // Stores pose landmarks in PIXEL coordinates (persistent until new image)
        let draggedPointIndex = -1;
        let isDragging = false;
        const pointRadius = 5;
        const hitRadius = pointRadius * 1.5;
        let dragOffsetX = 0, dragOffsetY = 0;

        // --- Visibility State ---
        let showFaceLandmarks = false; // Track visibility state
        let showPoseLandmarks = false; // Track visibility state

        // --- State ---
        let isCommentAreaInitialized = false;
        let selectedReferenceFaceIndex = null;
        let landmarkDB = null;

        // --- Constants ---
        const DB_NAME = 'mediaPipeModelDB';
        const DB_VERSION = 1;
        const MODEL_STORE_NAME = 'models';
        const FACE_MODEL_KEY = 'faceLandmarker_v1'; // Add versioning to keys
        const POSE_MODEL_KEY = 'poseLandmarkerHeavy_v1'; // Add versioning to keys
        const FACE_MODEL_URL = 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task';
        const POSE_MODEL_URL = 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task';

        // === IndexedDB Helper Functions (Adapted from TypeScript) ===

        async function openDB(name, version) {
            return new Promise((resolve, reject) => {
                addComment(`Opening model cache DB (${name} v${version})...`, 'info');
                const request = indexedDB.open(name, version);

                request.onupgradeneeded = function () {
                    try {
                        const db = request.result;
                        if (!db.objectStoreNames.contains(MODEL_STORE_NAME)) {
                            db.createObjectStore(MODEL_STORE_NAME, {keyPath: 'name'});
                            console.log(`Object store "${MODEL_STORE_NAME}" created.`);
                        }
                    } catch (err) {
                        console.error("Error during DB upgrade:", err);
                        addComment(`Error setting up model cache DB: ${err.message}`, 'error');
                        reject('Error during DB upgrade');
                    }
                };

                request.onsuccess = function () {
                    console.log(`DB ${name} v${version} opened successfully.`);
                    addComment('Model cache DB opened.', 'success');
                    resolve(request.result);
                };

                request.onerror = function (event) {
                    console.error('Error opening IndexedDB:', event.target.error);
                    addComment(`Error opening model cache DB: ${event.target.error}`, 'error');
                    reject('Error opening IndexedDB');
                };
            });
        }

        async function saveModelToDB(db, modelName, modelData) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    return reject('Database connection is not available.');
                }
                try {
                    const transaction = db.transaction(MODEL_STORE_NAME, 'readwrite');
                    const store = transaction.objectStore(MODEL_STORE_NAME);
                    const request = store.put({name: modelName, data: modelData}); // Storing Blob directly

                    request.onsuccess = () => {
                        console.log(`Model "${modelName}" saved to IndexedDB.`);
                        resolve();
                    };

                    request.onerror = (event) => {
                        console.error(`Error saving model "${modelName}" to IndexedDB:`, event.target.error);
                        reject(`Error saving model "${modelName}" to IndexedDB`);
                    };
                } catch (error) {
                    console.error(`Error initiating transaction to save "${modelName}":`, error);
                    reject(`Failed to start transaction for saving model "${modelName}"`);
                }
            });
        }


        async function getModelFromDB(db, modelName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    return reject('Database connection is not available.');
                }
                try {
                    const transaction = db.transaction(MODEL_STORE_NAME, 'readonly');
                    const store = transaction.objectStore(MODEL_STORE_NAME);
                    const request = store.get(modelName);

                    request.onsuccess = () => {
                        resolve(request.result?.data || null); // Returns Blob or null
                    };

                    request.onerror = (event) => {
                        console.error(`Error retrieving model "${modelName}" from IndexedDB:`, event.target.error);
                        reject(`Error retrieving model "${modelName}" from IndexedDB`);
                    };
                } catch (error) {
                    console.error(`Error initiating transaction to get "${modelName}":`, error);
                    reject(`Failed to start transaction for getting model "${modelName}"`);
                }
            });
        }

        async function fetchModelBlob(url) {
            addComment(`Workspaceing model from ${url}...`, 'info');
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch model: ${response.status} ${response.statusText}`);
            }
            const blob = await response.blob();
            addComment(`Successfully fetched model (${(blob.size / 1024 / 1024).toFixed(2)} MB).`, 'success');
            return blob;
        }

        async function getModelAssetBuffer(db, modelName, modelUrl) {
            try {
                // 1. Try to get from IndexedDB
                let modelBlob = await getModelFromDB(db, modelName);

                if (modelBlob) {
                    addComment(`Loading model "${modelName}" from cache...`, 'success');
                } else {
                    // 2. If not found, fetch from network
                    addComment(`Model "${modelName}" not in cache.`, 'info');
                    modelBlob = await fetchModelBlob(modelUrl);

                    // 3. Store the fetched blob in IndexedDB
                    try {
                        addComment(`Storing model "${modelName}" in cache...`, 'info');
                        await saveModelToDB(db, modelName, modelBlob);
                        addComment(`Model "${modelName}" stored successfully.`, 'success');
                    } catch (saveError) {
                        addComment(`Failed to store model "${modelName}" in cache: ${saveError}. Will use fetched version.`, 'error');
                        // Proceed with the fetched blob even if saving failed
                    }
                }

                // 4. Convert Blob to Uint8Array
                const arrayBuffer = await modelBlob.arrayBuffer();
                return new Uint8Array(arrayBuffer);

            } catch (error) {
                addComment(`Failed to load or fetch model "${modelName}": ${error.message || error}`, 'error');
                console.error(`Error processing model "${modelName}":`, error);
                return null; // Indicate failure
            }
        }
        // --- Initialization ---
        async function initializeApp() {
            if (canvasCtx) {drawingUtils = new DrawingUtils(canvasCtx);}
            else {console.error("Failed to get canvas context"); return;}
            updateIconStates();
            landmarkDB = await openDB(DB_NAME, DB_VERSION);
            await initializeFaceLandmarker();
            await initializePoseLandmarker();
        }

        // --- Utility Functions ---
        function addComment(message, type = 'info', username = 'System') { /* ... (no changes) ... */
            if (!commentArea) return; if (!isCommentAreaInitialized && (commentArea.innerHTML.includes('Initializing MediaPipe...') || commentArea.innerHTML.includes('Comments will appear here...'))) {commentArea.innerHTML = ''; isCommentAreaInitialized = true;} else if (commentArea.innerHTML === '') {isCommentAreaInitialized = true;}
            const cE = document.createElement('p'); const uS = document.createElement('span'); const mS = document.createElement('span'); uS.className = 'comment-username'; uS.textContent = username; mS.className = `comment-${type}`; mS.textContent = ` ${message}`; cE.appendChild(uS); cE.appendChild(mS); commentArea.appendChild(cE); commentArea.scrollTop = commentArea.scrollHeight;
        }
        function clearCanvas() {if (canvasCtx && overlayCanvas) {canvasCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);} }

        // --- MediaPipe Initialization ---
        async function initializeVisionResolver() { /* ... (no changes) ... */
            if (!visionResolver) {addComment('Loading MediaPipe Vision Tasks...', 'info'); try {visionResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"); addComment('Vision Tasks ready.', 'success');} catch (error) {console.error("Vision Tasks Init Error:", error); addComment(`Error initializing Vision Tasks: ${error.message || 'Unknown error'}`, 'error'); visionResolver = null; throw error;} } return visionResolver;
        }
        async function initializeFaceLandmarker() { /* ... (no changes) ... */
            try {
                const r = await initializeVisionResolver();
                if (!r) return; addComment('Loading Face Landmarker model...', 'info');
                const faceModelBuffer = await getModelAssetBuffer(landmarkDB, FACE_MODEL_KEY, FACE_MODEL_URL);
                if (!faceModelBuffer) {addComment(`Failed to load Face Landmarker model.`, 'error'); return;}
                faceLandmarker = await FaceLandmarker.createFromOptions(visionResolver, {
                    baseOptions: {
                        modelAssetBuffer: faceModelBuffer, // Use the buffer
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: true, // Kept original setting
                    runningMode: "IMAGE",
                    numFaces: 3 // Kept original setting
                });
                addComment('Face Landmarker loaded.', 'success');
                isFaceLandmarkerInitialized = true;
                updateIconStates();
            } catch (e) {
                console.error("Face Landmarker Init Error:", e);
                addComment(`Error initializing Face Landmarker: ${e.message || 'Unknown error'}`, 'error');
                isFaceLandmarkerInitialized = false;
                updateIconStates();
            }
        }
        async function initializePoseLandmarker() { /* ... (no changes) ... */
            try {
                const r = await initializeVisionResolver();
                if (!r) return; addComment('Loading Pose Landmarker model...', 'info');
                const poseModelBuffer = await getModelAssetBuffer(landmarkDB, POSE_MODEL_KEY, POSE_MODEL_URL);
                if (!poseModelBuffer) {addComment(`Failed to load Pose Landmarker model.`, 'error'); return;}
                poseLandmarker = await PoseLandmarker.createFromOptions(visionResolver, {
                    baseOptions: {
                        modelAssetBuffer: poseModelBuffer, // Use the buffer
                        delegate: "GPU"
                    },
                    runningMode: "IMAGE",
                    numPoses: 1 // Kept original setting
                });
                addComment('Pose Landmarker loaded.', 'success');
                isPoseLandmarkerInitialized = true; updateIconStates();
            } catch (e) {
                console.error("Pose Landmarker Init Error:", e);
                addComment(`Error initializing Pose Landmarker: ${e.message || 'Unknown error'}`, 'error');
                isPoseLandmarkerInitialized = false; updateIconStates();
            }
        }

        // --- UI State & Reset ---
        function updateIconStates() { /* ... (no changes) ... */
            const faceDisabled = !isFaceLandmarkerInitialized || !currentImageElement; iconFace.classList.toggle('disabled', faceDisabled); iconFace.classList.toggle('active', showFaceLandmarks && !faceDisabled);
            if (!currentImageElement) iconFace.title = "Load an image first"; else if (!isFaceLandmarkerInitialized) iconFace.title = "Face Landmarker not ready"; else iconFace.title = showFaceLandmarks ? "Hide Face Landmarks" : "Show Face Landmarks";
            const poseDisabled = !isPoseLandmarkerInitialized || !currentImageElement; iconPose.classList.toggle('disabled', poseDisabled); iconPose.classList.toggle('active', showPoseLandmarks && !poseDisabled);
            if (!currentImageElement) iconPose.title = "Load an image first"; else if (!isPoseLandmarkerInitialized) iconPose.title = "Pose Landmarker not ready"; else iconPose.title = showPoseLandmarks ? "Hide Pose Landmarks" : "Show Pose Landmarks";
        }
        function handleImageUpload(event) { // Resets everything including dragged points
            if (commentArea) {commentArea.innerHTML = '';} isCommentAreaInitialized = false; clearCanvas();
            currentImageElement = null; lastFaceDetections = null; lastPoseDetections = null;
            draggablePoseLandmarks = []; // Reset dragged points
            selectedReferenceFaceIndex = null; showFaceLandmarks = false; showPoseLandmarks = false;
            updateIconStates(); resetPreviewVisuals();
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) { /* ... (file reading logic - no changes) ... */
                addComment(`Loading image "${file.name}"...`, 'info'); const reader = new FileReader();
                reader.onload = function (e) {imagePreview.src = e.target.result; imagePreview.onload = () => {currentImageElement = imagePreview; imagePreviewContainer.classList.remove('hidden'); imagePreview.classList.remove('hidden'); placeholderText.classList.add('hidden'); resizeCanvasToImage(); addComment(`Image loaded. Ready for detection.`, 'success'); updateIconStates();}; imagePreview.onerror = () => {addComment(`Error displaying image.`, 'error'); resetFullPreview();};}
                reader.onerror = function (e) {addComment(`Error loading image file: ${e.target.error.message || 'Unknown error'}`, 'error'); resetFullPreview();}; reader.readAsDataURL(file);
            } else {const message = file ? `Invalid file type: "${file.type}".` : 'No file selected.'; addComment(message, 'error'); resetFullPreview();}
        }
        function resetPreviewVisuals() { /* ... (no changes) ... */
            imagePreviewContainer.classList.add('hidden'); imagePreview.src = '#'; imagePreview.classList.add('hidden'); placeholderText.classList.add('hidden');
        }
        function resetFullPreview() { // Resets everything including dragged points
            resetPreviewVisuals(); clearCanvas(); currentImageElement = null;
            lastFaceDetections = null; lastPoseDetections = null;
            draggablePoseLandmarks = []; // Reset dragged points
            selectedReferenceFaceIndex = null; showFaceLandmarks = false; showPoseLandmarks = false;
            updateIconStates(); hideFaceSelectionModal();
            if (imageUpload) {imageUpload.value = null;}
        }
        // Renamed back to clearOverlays, and now clears data
        function clearOverlays() {
            addComment('Clearing overlays and detection data...', 'info', 'sketchit');
            // Clear data
            lastFaceDetections = null;
            lastPoseDetections = null;
            draggablePoseLandmarks = []; // Clear dragged points as well

            // Reset UI state
            showFaceLandmarks = false; // Turn off visibility flags
            showPoseLandmarks = false;
            selectedReferenceFaceIndex = null; // Clear face selection for grid
            hideFaceSelectionModal(); // Ensure modal is hidden
            redrawCanvas(); // Redraw (will be empty as flags are false and data is null)
            updateIconStates(); // Update icon appearance
        }

        // --- Canvas Resizing ---
        function resizeCanvasToImage() { // Modified to use redrawCanvas
            if (!currentImageElement || !overlayCanvas || !imagePreviewContainer || !currentImageElement.naturalWidth) return;
            const img = currentImageElement; const canvas = overlayCanvas; const container = img.parentElement;
            const cW = container.offsetWidth; const cH = container.offsetHeight; const imgW = img.naturalWidth; const imgH = img.naturalHeight;
            const cRatio = cW / cH; const imgRatio = imgW / imgH; let rW, rH, oX, oY;
            if (imgRatio > cRatio) {rW = cW; rH = cW / imgRatio; oX = 0; oY = (cH - rH) / 2;}
            else {rH = cH; rW = cH * imgRatio; oY = 0; oX = (cW - rW) / 2;}
            canvas.width = rW; canvas.height = rH;
            canvas.style.left = `${oX}px`; canvas.style.top = `${oY}px`; canvas.style.width = `${rW}px`; canvas.style.height = `${rH}px`;

            // Recalculate draggable points from NORMALIZED data if pose results exist
            // Important: Use lastPoseDetections (normalized) NOT draggablePoseLandmarks (pixels)
            if (lastPoseDetections && lastPoseDetections.landmarks && lastPoseDetections.landmarks.length > 0) {
                console.log("Resize: Recalculating draggable pose landmarks from normalized data");
                draggablePoseLandmarks = lastPoseDetections.landmarks[0].map(lm => ({
                    x: lm.x * canvas.width, y: lm.y * canvas.height, visibility: lm.visibility
                }));
            } else {
                // If no original pose data exists (e.g., after reset), clear draggable points
                draggablePoseLandmarks = [];
            }

            redrawCanvas(); // Redraw based on current visibility flags
        }

        // --- Central Drawing Function ---
        function redrawCanvas() { /* ... (no changes) ... */
            clearCanvas();
            if (showFaceLandmarks && lastFaceDetections) {drawFaceLandmarksInternal(lastFaceDetections, selectedReferenceFaceIndex);}
            if (showPoseLandmarks && draggablePoseLandmarks.length > 0) {drawPoseLandmarksInternal();}
            updateIconStates();
        }

        // --- Face Detection & Drawing ---
        function showFaceSelectionModal(numFaces) { /* ... (no changes) ... */
            modalFaceButtons.innerHTML = ''; for (let i = 0; i < numFaces; i++) {const b = document.createElement('button'); b.textContent = `Face ${i + 1}`; b.classList.add('select-face-btn'); b.dataset.index = i; b.addEventListener('click', handleFaceSelection); modalFaceButtons.appendChild(b);} faceSelectionModal.classList.add('visible');
        }
        function hideFaceSelectionModal() { /* ... (no changes) ... */ faceSelectionModal.classList.remove('visible');}
        function handleFaceSelection(event) { /* ... (no changes) ... */
            const idx = parseInt(event.target.dataset.index, 10); selectedReferenceFaceIndex = idx; addComment(`Selected Face ${idx + 1} for grid.`, 'success', 'User'); hideFaceSelectionModal(); redrawCanvas();
        }
        function drawFaceLandmarksInternal(results, gridFaceIndex = null) {
            if (!results || !results.faceLandmarks || !drawingUtils) return;
            if (results.faceLandmarks.length === 0) return;
            console.log("Drawing internal face landmarks...");
            results.faceLandmarks.forEach((landmarks, index) => {
                const isSelected = index === gridFaceIndex;
                const eyeC = isSelected ? "#FF3030" : "#FFA0A0", lipC = isSelected ? "#E0E0E0" : "#B0B0B0", ovalC = isSelected ? "#E0E0E0" : "#B0B0B0";
                if (landmarks && landmarks.length > 0) {
                    try {
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE, {color: eyeC, lineWidth: 1});
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE, {color: eyeC, lineWidth: 1});
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL, {color: ovalC, lineWidth: 1});
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_LIPS, {color: lipC, lineWidth: 1});
                    }
                    catch (e) {
                        if (isSelected)
                            addComment(`Error drawing basic landmarks for Face ${index + 1}.`, 'error');
                    }
                } else {
                    if (isSelected)
                        addComment(`No landmarks for selected Face ${index + 1}.`, 'info');
                    return;
                }
                if (isSelected) {
                    const pxLm = landmarks.map(p => ({
                        x: p.x * overlayCanvas.width,
                        y: p.y * overlayCanvas.height
                    }));

                    let fMinX = Infinity, fMaxX = -Infinity, fMinY = Infinity, fMaxY = -Infinity;
                    pxLm.forEach(p => {
                        if (p.x < fMinX) fMinX = p.x;
                        if (p.x > fMaxX) fMaxX = p.x;
                        if (p.y < fMinY) fMinY = p.y;
                        if (p.y > fMaxY) fMaxY = p.y;
                    });
                    let fLength = Math.abs(fMaxX - fMinX);
                    let fHeight = Math.abs(fMaxY - fMinY);
                    let fMaxDimension = Math.max(fLength, fHeight);
                    let fMidX = (fMinX + fMaxX) / 2;
                    let fMidY = (fMinY + fMaxY) / 2;
                    let gridStartX = fMidX - fMaxDimension / 2;
                    let gridStartY = fMidY- fMaxDimension / 2;
                    let gridEndX = fMidX + fMaxDimension / 2;
                    let gridEndY = fMidY + fMaxDimension / 2;
                    let horizontalLines = [];
                    let verticalLines = [];
                    let verticalLineX = gridEndX
                    while (verticalLineX < overlayCanvas.height) {
                        verticalLines.push(verticalLineX);
                        verticalLineX += fMaxDimension;
                    }
                    verticalLineX = gridStartX
                    while (verticalLineX > 0) {
                        verticalLines.push(verticalLineX);
                        verticalLineX -= fMaxDimension;
                    }
                    let horizontalLineY = gridEndY
                    while (horizontalLineY < overlayCanvas.width) {
                        horizontalLines.push(horizontalLineY);
                        horizontalLineY += fMaxDimension;
                    }
                    horizontalLineY = gridStartY
                    while (horizontalLineY > 0) {
                        horizontalLines.push(horizontalLineY);
                        horizontalLineY -= fMaxDimension;
                    }
                    canvasCtx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    canvasCtx.lineWidth = 1;
                    horizontalLines.forEach(y => {
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(0, y);
                        canvasCtx.lineTo(overlayCanvas.width, y);
                        canvasCtx.stroke();
                    });
                    canvasCtx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    verticalLines.forEach(x => {
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(x, 0);
                        canvasCtx.lineTo(x, overlayCanvas.height);
                        canvasCtx.stroke();
                    });

                    const horizontalFaceLines = [gridStartY + fMaxDimension / 3, gridStartY + (2 * fMaxDimension) / 3];
                    const verticalFaceLines = [gridStartX + fMaxDimension / 3, gridStartX + (2 * fMaxDimension) / 3];

                    canvasCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                    canvasCtx.lineWidth = 1;
                    horizontalFaceLines.forEach(y => {
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(gridStartX, y);
                        canvasCtx.lineTo(gridEndX, y);
                        canvasCtx.stroke();
                    });

                    canvasCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
                    verticalFaceLines.forEach(x => {
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(x, gridStartY);
                        canvasCtx.lineTo(x, gridEndY);
                        canvasCtx.stroke();
                    });

                }
            });
        }

        function handleFaceIconClick() { // Toggle logic updated
            if (!isFaceLandmarkerInitialized || !faceLandmarker || !currentImageElement || iconFace.classList.contains('disabled')) return;
            showFaceLandmarks = !showFaceLandmarks; // Toggle
            if (showFaceLandmarks) {
                addComment('Showing face landmarks...', 'info');
                if (!lastFaceDetections) { // Detect only if no data
                    addComment('Running face detection...', 'info');
                    try {
                        const results = faceLandmarker.detect(currentImageElement); const numFaces = results.faceLandmarks.length;
                        if (numFaces > 0) {addComment(`Found ${numFaces} face(s).`, 'success'); lastFaceDetections = results; if (numFaces > 1) {selectedReferenceFaceIndex = null; addComment(`Select face for grid.`, 'info'); showFaceSelectionModal(numFaces); return;} else {selectedReferenceFaceIndex = 0;} }
                        else {addComment('No faces detected.', 'info'); lastFaceDetections = null; showFaceLandmarks = false;}
                    } catch (error) {addComment(`Face detection failed: ${error.message || 'Unknown error'}`, 'error'); lastFaceDetections = null; showFaceLandmarks = false;}
                }
                redrawCanvas(); // Redraw now
            } else {
                addComment('Hiding face landmarks.', 'info');
                hideFaceSelectionModal();
                redrawCanvas(); // Redraw without face
            } updateIconStates();
        }

        // --- Pose Detection & Drawing ---
        function drawPoseLandmarksInternal() { /* ... (no changes) ... */
            if (!draggablePoseLandmarks || draggablePoseLandmarks.length === 0 || !drawingUtils) return;
            const connections = PoseLandmarker.POSE_CONNECTIONS;
            if (!connections) {console.error("Pose connections not available."); return;}
            console.log("Drawing internal pose landmarks...");
            canvasCtx.strokeStyle = '#00FF00';
            canvasCtx.lineWidth = 2;
            connections.forEach((c) => {
                const sIdx = c.start,
                    eIdx = c.end;
                if (sIdx <= 10) {
                    // skip the first 10 points
                    return;
                }
                if (sIdx < draggablePoseLandmarks.length && eIdx < draggablePoseLandmarks.length) {
                    const sP = draggablePoseLandmarks[sIdx], eP = draggablePoseLandmarks[eIdx];
                    canvasCtx.beginPath(); canvasCtx.moveTo(sP.x, sP.y);
                    canvasCtx.lineTo(eP.x, eP.y); canvasCtx.stroke();
                }
            });
            canvasCtx.fillStyle = '#FF0000';
            draggablePoseLandmarks.forEach((p, i) => {
                if (i <= 10) {
                    // skip drawing points for the face (landmarks 0-10)
                    return; // Equivalent to 'continue' in a forEach callback
                }
                canvasCtx.beginPath();
                canvasCtx.arc(p.x, p.y, pointRadius, 0, 2 * Math.PI);
                canvasCtx.fill();
                if (isDragging && i === draggedPointIndex) {
                    canvasCtx.strokeStyle = '#0000FF';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.stroke();
                }
            });
        }
        function handlePoseIconClick() { // Toggle logic updated
            if (!isPoseLandmarkerInitialized || !poseLandmarker || !currentImageElement || iconPose.classList.contains('disabled')) return;
            showPoseLandmarks = !showPoseLandmarks; // Toggle
            if (showPoseLandmarks) {
                addComment('Showing pose landmarks...', 'info');
                if (!lastPoseDetections) { // Detect only if no data
                    addComment('Running pose detection...', 'info');
                    try {
                        const results = poseLandmarker.detect(currentImageElement);
                        if (results.landmarks.length > 0) {addComment(`Found ${results.landmarks.length} pose(s).`, 'success'); lastPoseDetections = results; draggablePoseLandmarks = results.landmarks[0].map(lm => ({x: lm.x * overlayCanvas.width, y: lm.y * overlayCanvas.height, visibility: lm.visibility}));}
                        else {addComment('No poses detected.', 'info'); lastPoseDetections = null; draggablePoseLandmarks = []; showPoseLandmarks = false;}
                    } catch (error) {addComment(`Pose detection failed: ${error.message || 'Unknown error'}`, 'error'); lastPoseDetections = null; draggablePoseLandmarks = []; showPoseLandmarks = false;}
                } else if (draggablePoseLandmarks.length === 0 && lastPoseDetections?.landmarks?.length > 0) {
                    // Recalculate draggable points if they were cleared but data exists (e.g., after resize or reset)
                    addComment('Restoring previous pose data...', 'info');
                    draggablePoseLandmarks = lastPoseDetections.landmarks[0].map(lm => ({x: lm.x * overlayCanvas.width, y: lm.y * overlayCanvas.height, visibility: lm.visibility}));
                }
                redrawCanvas(); // Redraw now
            } else {
                addComment('Hiding pose landmarks.', 'info');
                // Don't clear draggablePoseLandmarks here when hiding
                redrawCanvas(); // Redraw without pose
            } updateIconStates();
        }

        // --- Drag and Drop Logic ---
        function getMousePos(canvas, evt) { /* ... (no changes) ... */
            const rect = canvas.getBoundingClientRect(); const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX; const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY; return {x: clientX - rect.left, y: clientY - rect.top};
        }
        function handleMouseDown(e) { /* ... (no changes) ... */
            if (!showPoseLandmarks) return; e.preventDefault(); const pos = getMousePos(overlayCanvas, e);
            for (let i = 0; i < draggablePoseLandmarks.length; i++) {const p = draggablePoseLandmarks[i]; const dx = pos.x - p.x; const dy = pos.y - p.y; if (dx * dx + dy * dy < hitRadius * hitRadius) {isDragging = true; draggedPointIndex = i; overlayCanvas.classList.add('dragging'); dragOffsetX = dx; dragOffsetY = dy; console.log(`Dragging point ${i}`); return;} }
        }
        function handleMouseMove(e) { /* ... (no changes) ... */
            if (!showPoseLandmarks) {overlayCanvas.classList.remove('point-hover'); return;} const pos = getMousePos(overlayCanvas, e);
            if (!isDragging) {let hovering = false; for (let i = 0; i < draggablePoseLandmarks.length; i++) {const p = draggablePoseLandmarks[i]; const dx = pos.x - p.x; const dy = pos.y - p.y; if (dx * dx + dy * dy < hitRadius * hitRadius) {hovering = true; break;} } overlayCanvas.classList.toggle('point-hover', hovering);}
            if (isDragging && draggedPointIndex !== -1) {e.preventDefault(); const dP = draggablePoseLandmarks[draggedPointIndex]; dP.x = pos.x - dragOffsetX; dP.y = pos.y - dragOffsetY; dP.x = Math.max(0, Math.min(overlayCanvas.width, dP.x)); dP.y = Math.max(0, Math.min(overlayCanvas.height, dP.y)); requestAnimationFrame(redrawCanvas);}
        }
        function handleMouseUp(e) { /* ... (no changes) ... */
            if (isDragging) {console.log(`Finished dragging point ${draggedPointIndex}`);} isDragging = false; draggedPointIndex = -1; overlayCanvas.classList.remove('dragging'); overlayCanvas.classList.remove('point-hover'); dragOffsetX = 0; dragOffsetY = 0;
        }

        // --- Event Listeners Setup ---
        imageUpload.addEventListener('change', handleImageUpload);
        iconFace.addEventListener('click', handleFaceIconClick);
        iconPose.addEventListener('click', handlePoseIconClick);
        iconRestart.addEventListener('click', () => {if (currentImageElement) clearOverlays();}); // Use updated handler
        cancelModalButton.addEventListener('click', () => {addComment('Face selection cancelled.', 'info'); hideFaceSelectionModal(); selectedReferenceFaceIndex = null; redrawCanvas();});
        faceSelectionModal.addEventListener('click', (event) => {if (event.target === faceSelectionModal) {addComment('Face selection cancelled.', 'info'); hideFaceSelectionModal(); selectedReferenceFaceIndex = null; redrawCanvas();} });

        // Drag and Drop Listeners
        overlayCanvas.addEventListener('mousedown', handleMouseDown); overlayCanvas.addEventListener('mousemove', handleMouseMove); overlayCanvas.addEventListener('mouseup', handleMouseUp); overlayCanvas.addEventListener('mouseout', handleMouseUp);
        overlayCanvas.addEventListener('touchstart', handleMouseDown, {passive: false}); overlayCanvas.addEventListener('touchmove', handleMouseMove, {passive: false}); overlayCanvas.addEventListener('touchend', handleMouseUp); overlayCanvas.addEventListener('touchcancel', handleMouseUp);

        // Window Resize Listener
        let resizeTimeout; window.addEventListener('resize', () => {clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => {if (currentImageElement && !imagePreviewContainer.classList.contains('hidden')) {console.log("Window resized, recalculating..."); resizeCanvasToImage();} }, 150);});

        // --- Initial Page Load Setup ---
        initializeApp();

    </script>

</body>

</html>
