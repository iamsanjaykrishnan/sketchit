<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sketchit a tool to study proportions</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        /* Apply Inter font globally */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.2s ease;
        }

        /* Style for dragover state */
        body.dragover {
            background-color: #e0f2fe;
            /* Light blue background */
        }

        .drop-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 4px dashed #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        body.dragover .drop-indicator {
            opacity: 1;
            visibility: visible;
        }

        .drop-indicator-text {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2563eb;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 1rem 2rem;
            border-radius: 0.5rem;
        }

        /* Hide the default file input */
        #imageUpload {
            display: none;
        }

        /* Style for the image preview container */
        .display-card {
            max-width: 480px;
            width: 100%;
        }

        /* Container for image and canvas */
        .image-display-container {
            position: relative;
            background-color: #f3f4f6;
            /* bg-gray-100 */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            aspect-ratio: 1 / 1;
            max-height: 600px;
        }

        /* Ensure image fits well */
        .display-card img#imagePreview {
            display: block;
            max-width: 100%;
            max-height: 100%;
            height: auto;
            width: auto;
            object-fit: contain;
        }

        /* Canvas overlay */
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
            touch-action: none;
        }

        /* Cursors for different states */
        #overlayCanvas.manual-grid-drawing,
        #overlayCanvas.manual-grid-adjusting:not(.dragging-grid-handle):not(.dragging-grid-square):not(.handle-hover):not(.square-hover) {
            cursor: crosshair;
        }

        #overlayCanvas.dragging-pose,
        #overlayCanvas.point-hover {
            cursor: grab;
        }

        #overlayCanvas.dragging-grid-handle,
        #overlayCanvas.handle-hover {
            cursor: grab;
        }

        #overlayCanvas.dragging-grid-square,
        #overlayCanvas.square-hover {
            cursor: move;
        }

        /* Material Symbols styling */
        .material-symbols-outlined {
            vertical-align: middle;
            font-size: 24px;
            cursor: pointer;
            transition: color 0.2s ease;
            display: inline-block;
            line-height: 1;
        }

        .material-symbols-outlined.active {
            color: #3b82f6;
        }

        .material-symbols-outlined.disabled {
            cursor: not-allowed;
            opacity: 0.5;
            color: #6b7280;
        }

        .material-symbols-outlined.disabled.active {
            color: #6b7280;
            opacity: 0.5;
        }

        /* Comments area styling */
        #commentArea {
            max-height: 100px;
            overflow-y: auto;
            padding-top: 0.5rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            color: #1f2937;
        }

        #commentArea p {
            margin-bottom: 0.375rem;
            word-break: break-word;
        }

        #commentArea .comment-username {
            font-weight: 600;
            margin-right: 0.375rem;
            color: #111827;
        }

        #commentArea .comment-error {
            color: #ef4444;
        }

        #commentArea .comment-success {
            color: #22c55e;
        }

        #commentArea .comment-info {
            color: #374151;
        }

        #commentArea .comment-warning {
            color: #f97316;
        }

        /* Modal Styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 1.5rem 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90%;
            width: 350px;
            text-align: center;
        }

        .modal-title {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #1f2937;
        }

        .modal-body {
            margin-bottom: 1.5rem;
            color: #4b5563;
        }

        .modal-actions button {
            margin: 0 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        .modal-actions button.select-face-btn {
            background-color: #3b82f6;
            color: white;
        }

        .modal-actions button.select-face-btn:hover {
            background-color: #2563eb;
        }

        .modal-actions button.cancel-btn {
            background-color: #e5e7eb;
            color: #374151;
        }

        .modal-actions button.cancel-btn:hover {
            background-color: #d1d5db;
        }

        /* Adjustment Handle Styling */
        .adjustment-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: rgba(255, 0, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            cursor: grab;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
        }

        .adjustment-handle[data-type^="t"],
        .adjustment-handle[data-type^="b"],
        .adjustment-handle[data-type^="m"] {
            border-radius: 0;
        }

        #overlayCanvas.manual-grid-adjusting .adjustment-handle {
            pointer-events: auto;
        }

        /* Confirm Button Styling */
        #confirmGridButton {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        /* Colorful Upload Card Styling - Purple to Pink */
        #uploadCard {
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
            /* Purple to Pink */
            border: none;
            transition: box-shadow 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        #uploadCard:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        #uploadCard h2 {
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        #uploadCard p {
            color: #f3e8ff;
            /* Lighter purple/pink text */
        }

        #uploadCard .dashed-zone {
            border: 2px dashed rgba(255, 255, 255, 0.5);
            background-color: rgba(255, 255, 255, 0.1);
            transition: border-color 0.3s ease, background-color 0.3s ease;
        }

        #uploadCard:hover .dashed-zone {
            border-color: rgba(255, 255, 255, 0.8);
            background-color: rgba(255, 255, 255, 0.2);
        }

        #uploadCard .dashed-zone .material-symbols-outlined {
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.3s ease;
            font-size: 40px;
        }

        #uploadCard:hover .dashed-zone .material-symbols-outlined {
            color: white;
        }

        #uploadCard .dashed-zone .upload-text-primary {
            color: white;
            font-weight: 500;
        }

        #uploadCard .dashed-zone .upload-text-secondary {
            color: #fce7f3;
            /* Lighter pink text */
        }

        /* External New Upload Button Styling */
        #newUploadButtonExt {
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.5rem;
            border: 1px solid transparent;
            font-size: 1rem;
            font-weight: 500;
            border-radius: 0.375rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            color: white;
            background-color: #4f46e5;
            transition: background-color 0.15s ease-in-out;
            margin-bottom: 1.5rem;
            width: auto;
        }

        #newUploadButtonExt:not(.hidden) {
            display: inline-flex;
        }

        #newUploadButtonExt:hover {
            background-color: #4338ca;
        }

        #newUploadButtonExt:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #6366f1;
        }

        #newUploadButtonExt .material-symbols-outlined {
            margin-right: 0.5rem;
            font-size: 20px;
            vertical-align: middle;
            color: white;
            cursor: pointer;
        }

        /* Privacy/Terms Policy Card Styling */
        .policy-card {
            max-width: 480px;
            /* Match width of other cards */
            width: 100%;
            margin-top: 0.75rem;
            /* Space between policy cards */
            background-color: #f9fafb;
            /* Slightly off-white */
            border: 1px solid #e5e7eb;
            /* Soft border */
        }
    </style>
</head>

<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="drop-indicator">
        <span class="drop-indicator-text">Drop image here</span>
    </div>

    <div class="w-full max-w-md mx-auto flex flex-col items-center">

        <label id="uploadCard" for="imageUpload"
            class="cursor-pointer rounded-lg shadow-lg p-6 md:p-8 w-full text-center mb-6 block">
            <h2 class="text-2xl font-bold mb-3">Sketchit</h2>
            <p class="text-base mb-6">
                Sketchit is a simple web tool designed for artists. It uses MediaPipe library to detect human faces or
                body poses in an uploaded image and overlays a helpful reference grid, making it easier to sketch or
                study proportions
            </p>
            <div class="dashed-zone flex flex-col items-center justify-center rounded-lg p-8">
                <span class="material-symbols-outlined mb-3">upload_file</span>
                <span class="upload-text-primary text-lg">Click to upload</span>
                <span class="upload-text-secondary text-sm mt-1">or drag and drop an image</span>
            </div>
        </label>
        <input type="file" id="imageUpload" accept="image/*">
        <button id="newUploadButtonExt" class="hidden">
            <span class="material-symbols-outlined">upload</span>
            Upload New Image
        </button>
        <div id="imagePreviewContainer"
            class="display-card bg-white border border-gray-300 rounded-lg shadow-md overflow-hidden hidden mx-auto">
            <div class="p-3 border-b border-gray-200 flex items-center justify-between space-x-3">
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center">
                        <span class="material-symbols-outlined text-gray-500 text-lg">person</span>
                    </div>
                    <span class="font-semibold text-sm text-gray-800">sketchit</span>
                </div>
            </div>

            <div class="relative">
                <div class="image-display-container">
                    <img id="imagePreview" src="#" alt="Image Preview" class="block">
                    <canvas id="overlayCanvas"></canvas>
                    <div id="placeholderText" class="text-center text-gray-500 p-10 hidden">Select an image to preview
                    </div>
                </div>
                <div id="adjustmentHandlesContainer" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                </div>
                <button id="confirmGridButton"
                    class="absolute bottom-4 left-1/2 transform -translate-x-1/2 px-4 py-2 bg-green-500 text-white rounded-md shadow-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 opacity-0 invisible pointer-events-none z-20">
                    Confirm Grid
                </button>
            </div>

            <div class="p-3 border-t border-gray-200 space-y-3">
                <div class="flex space-x-4 items-center">
                    <span id="iconFace" class="material-symbols-outlined text-gray-700 hover:text-gray-900 disabled"
                        title="Toggle Face Landmarks">face</span>
                    <span id="iconPose" class="material-symbols-outlined text-gray-700 hover:text-gray-900 disabled"
                        title="Toggle Pose Landmarks">accessibility_new</span>
                    <span id="iconGrid" class="material-symbols-outlined text-gray-700 hover:text-gray-900 disabled"
                        title="Manually Draw Grid Square">grid_on</span>
                    <span id="iconRestart" class="material-symbols-outlined text-gray-700 hover:text-gray-900"
                        title="Clear All Overlays & Data">restart_alt</span>
                </div>
                <div id="commentArea">
                    <p class="comment-info"><span class="comment-username">System</span>Initializing MediaPipe...</p>
                </div>
            </div>
        </div>
        <div id="privacyPolicyCard" class="policy-card rounded-lg shadow-sm p-3 text-center">
            <ul class="text-xs text-gray-500 text-left list-disc pl-5 space-y-1">
                <li>
                    <span class="font-medium">Privacy Note:</span>
                    Your images are processed directly in your browser using MediaPipe library.
                </li>
                <li>
                    <span class="font-medium">Terms of Use:</span>
                    This tool is provided 'as-is' without warranty for creative use. <a
                        href="https://ai.google.dev/edge/mediapipe/legal/tos" target="_blank" rel="noopener noreferrer"
                        class="underline text-indigo-600 hover:text-indigo-800 ml-1">MediaPipe Terms apply.</a> Use
                    responsibly.<br>
                </li>
                <li>
                    <span class="font-medium ">Note:</span> By uploading an image you agree to our terms and policy.
                </li>
            </ul>
        </div>
    </div>

    <div id="faceSelectionModal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">Select Reference Face</h3>
            <p class="modal-body">Multiple faces detected. Please select the face to use for grid drawing.</p>
            <div id="modalFaceButtons" class="modal-actions flex flex-wrap justify-center gap-2 mb-4"></div>
            <div class="modal-actions">
                <button id="cancelModalButton" class="cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <script type="module">
        import {
            FaceLandmarker, PoseLandmarker,
            FilesetResolver, DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // --- DOM Elements ---
        const imageUpload = document.getElementById('imageUpload');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreview = document.getElementById('imagePreview');
        const placeholderText = document.getElementById('placeholderText');
        const commentArea = document.getElementById('commentArea');
        const iconFace = document.getElementById('iconFace');
        const iconPose = document.getElementById('iconPose');
        const iconGrid = document.getElementById('iconGrid');
        const iconRestart = document.getElementById('iconRestart');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const canvasCtx = overlayCanvas.getContext('2d');
        const faceSelectionModal = document.getElementById('faceSelectionModal');
        const modalFaceButtons = document.getElementById('modalFaceButtons');
        const cancelModalButton = document.getElementById('cancelModalButton');
        const adjustmentHandlesContainer = document.getElementById('adjustmentHandlesContainer');
        const confirmGridButton = document.getElementById('confirmGridButton');
        const bodyElement = document.body;
        const uploadCard = document.getElementById('uploadCard');
        const newUploadButtonExt = document.getElementById('newUploadButtonExt'); // Get the EXTERNAL new upload button

        // --- MediaPipe Variables ---
        let faceLandmarker, poseLandmarker, drawingUtils, visionResolver = null;
        let isFaceLandmarkerInitialized = false, isPoseLandmarkerInitialized = false;
        let currentImageElement = null;
        let lastFaceDetections = null, lastPoseDetections = null;

        // --- Draggable State (Pose) ---
        let draggablePoseLandmarks = [];
        let draggedPointInfo = null;
        let isDraggingPosePoint = false;
        const pointRadius = 5;
        const hitRadius = pointRadius * 1.5;
        let dragOffsetX = 0, dragOffsetY = 0;

        // --- Manual Grid State ---
        let isManualGridModeActive = false;
        let isDrawingManualGrid = false;
        let isAdjustingManualGrid = false;
        let manualGridStartX = 0, manualGridStartY = 0;
        let manualGridCurrentX = 0, manualGridCurrentY = 0;
        let manualGridRect = null;
        let finalManualGridRect = null;
        let showFinalManualGrid = false;
        const handleSize = 10;
        const handleHitRadius = handleSize * 1.5;
        let adjustmentHandles = [];
        let draggedHandleType = null;
        let isDraggingGridSquare = false;
        let gridDragStartX = 0, gridDragStartY = 0;

        // --- Hover State (for cursors) ---
        let isHoveringPosePoint = false;
        let isHoveringGridHandle = false;
        let isHoveringGridSquare = false;

        // --- Visibility State ---
        let showFaceLandmarks = false;
        let showPoseLandmarks = false;

        // --- State ---
        let isCommentAreaInitialized = false;
        let selectedReferenceFaceIndex = null;
        let landmarkDB = null;

        // --- Constants ---
        const DB_NAME = 'mediaPipeModelDB';
        const DB_VERSION = 1;
        const MODEL_STORE_NAME = 'models';
        const FACE_MODEL_KEY = 'faceLandmarker_v1';
        const POSE_MODEL_KEY = 'poseLandmarkerHeavy_v1';
        const FACE_MODEL_URL = 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task';
        const POSE_MODEL_URL = 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task';
        const MIN_GRID_SIZE = 10;

        // === IndexedDB Helper Functions ===
        // ... (Unchanged) ...
        async function openDB(name, version) {
            return new Promise((resolve, reject) => {
                addComment(`Opening model cache DB (${name} v${version})...`, 'info');
                const request = indexedDB.open(name, version);
                request.onupgradeneeded = function () {
                    try {
                        const db = request.result;
                        if (!db.objectStoreNames.contains(MODEL_STORE_NAME)) {
                            db.createObjectStore(MODEL_STORE_NAME, {keyPath: 'name'});
                        }
                    } catch (err) {reject('Error during DB upgrade');}
                };
                request.onsuccess = () => resolve(request.result);
                request.onerror = (e) => reject('Error opening IndexedDB');
            });
        }
        async function saveModelToDB(db, modelName, modelData) {
            return new Promise((resolve, reject) => {
                if (!db) return reject('DB not available.');
                try {
                    const tx = db.transaction(MODEL_STORE_NAME, 'readwrite');
                    const store = tx.objectStore(MODEL_STORE_NAME);
                    const request = store.put({name: modelName, data: modelData});
                    request.onsuccess = () => resolve();
                    request.onerror = (e) => reject(`Error saving ${modelName}`);
                } catch (e) {reject(`Error saving ${modelName}`);}
            });
        }
        async function getModelFromDB(db, modelName) {
            return new Promise((resolve, reject) => {
                if (!db) return reject('DB not available.');
                try {
                    const tx = db.transaction(MODEL_STORE_NAME, 'readonly');
                    const store = tx.objectStore(MODEL_STORE_NAME);
                    const request = store.get(modelName);
                    request.onsuccess = () => resolve(request.result?.data || null);
                    request.onerror = (e) => reject(`Error getting ${modelName}`);
                } catch (e) {reject(`Error getting ${modelName}`);}
            });
        }
        async function fetchModelBlob(url) {
            addComment(`Downloading model from ${url}...`, 'info');
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            const blob = await response.blob();
            addComment(`Fetched model (${(blob.size / 1024 / 1024).toFixed(2)} MB).`, 'success');
            return blob;
        }
        async function getModelAssetBuffer(db, modelName, modelUrl) {
            try {
                let modelBlob = await getModelFromDB(db, modelName);
                if (modelBlob) {addComment(`Loading ${modelName} from cache...`, 'success');}
                else {
                    addComment(`${modelName} not in cache.`, 'info');
                    modelBlob = await fetchModelBlob(modelUrl);
                    try {
                        addComment(`Storing ${modelName} in cache...`, 'info');
                        await saveModelToDB(db, modelName, modelBlob);
                        addComment(`${modelName} stored.`, 'success');
                    } catch (saveError) {addComment(`Failed to store ${modelName}: ${saveError}.`, 'warning');}
                }
                const arrayBuffer = await modelBlob.arrayBuffer();
                return new Uint8Array(arrayBuffer);
            } catch (error) {
                addComment(`Failed to load/fetch ${modelName}: ${error}`, 'error');
                return null;
            }
        }

        // --- Initialization ---
        async function initializeApp() {
            if (canvasCtx) {drawingUtils = new DrawingUtils(canvasCtx);}
            else {console.error("Failed to get canvas context"); return;}
            resetCommonState(); // Ensure initial state is correct
            landmarkDB = await openDB(DB_NAME, DB_VERSION);
            await initializeFaceLandmarker();
            await initializePoseLandmarker();
            addComment('Ready. Upload an image or drop it here to start.', 'info');
        }

        // --- Utility Functions ---
        function addComment(message, type = 'info', username = 'System') {
            if (!commentArea) return; if (!isCommentAreaInitialized && (commentArea.innerHTML.includes('Initializing MediaPipe...') || commentArea.innerHTML.includes('Comments will appear here...'))) {commentArea.innerHTML = ''; isCommentAreaInitialized = true;} else if (commentArea.innerHTML === '') {isCommentAreaInitialized = true;}
            const cE = document.createElement('p'); const uS = document.createElement('span'); const mS = document.createElement('span'); uS.className = 'comment-username'; uS.textContent = username; mS.className = `comment-${type}`; mS.textContent = ` ${message}`; cE.appendChild(uS); cE.appendChild(mS); commentArea.appendChild(cE); commentArea.scrollTop = commentArea.scrollHeight;
        }
        function clearCanvas() {if (canvasCtx && overlayCanvas) {canvasCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);} }

        // --- MediaPipe Initialization ---
        // ... (Unchanged: initializeVisionResolver, initializeFaceLandmarker, initializePoseLandmarker) ...
        async function initializeVisionResolver() {
            if (!visionResolver) {addComment('Loading MediaPipe Vision Tasks...', 'info'); try {visionResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"); addComment('Vision Tasks ready.', 'success');} catch (error) {console.error("Vision Tasks Init Error:", error); addComment(`Error initializing Vision Tasks: ${error.message || 'Unknown error'}`, 'error'); visionResolver = null; throw error;} } return visionResolver;
        }
        async function initializeFaceLandmarker() {
            try {
                const r = await initializeVisionResolver();
                if (!r) return; addComment('Loading Face Landmarker model...', 'info');
                const faceModelBuffer = await getModelAssetBuffer(landmarkDB, FACE_MODEL_KEY, FACE_MODEL_URL);
                if (!faceModelBuffer) {addComment(`Failed to load Face Landmarker model.`, 'error'); return;}
                faceLandmarker = await FaceLandmarker.createFromOptions(visionResolver, {
                    baseOptions: {modelAssetBuffer: faceModelBuffer, delegate: "GPU"},
                    outputFaceBlendshapes: true, runningMode: "IMAGE", numFaces: 3
                });
                addComment('Face Landmarker loaded.', 'success');
                isFaceLandmarkerInitialized = true; updateIconStates();
            } catch (e) {console.error("Face Landmarker Init Error:", e); addComment(`Error initializing Face Landmarker: ${e}`, 'error'); isFaceLandmarkerInitialized = false; updateIconStates();}
        }
        async function initializePoseLandmarker() {
            try {
                const r = await initializeVisionResolver();
                if (!r) return; addComment('Loading Pose Landmarker model...', 'info');
                const poseModelBuffer = await getModelAssetBuffer(landmarkDB, POSE_MODEL_KEY, POSE_MODEL_URL);
                if (!poseModelBuffer) {addComment(`Failed to load Pose Landmarker model.`, 'error'); return;}
                poseLandmarker = await PoseLandmarker.createFromOptions(visionResolver, {
                    baseOptions: {modelAssetBuffer: poseModelBuffer, delegate: "GPU"},
                    runningMode: "IMAGE", numPoses: 3
                });
                addComment('Pose Landmarker loaded.', 'success');
                isPoseLandmarkerInitialized = true; updateIconStates();
            } catch (e) {console.error("Pose Landmarker Init Error:", e); addComment(`Error initializing Pose Landmarker: ${e}`, 'error'); isPoseLandmarkerInitialized = false; updateIconStates();}
        }

        // --- Reset Common State ---
        function resetCommonState() {
            if (commentArea) {commentArea.innerHTML = '';}
            isCommentAreaInitialized = false;
            clearCanvas();
            currentImageElement = null;
            lastFaceDetections = null;
            lastPoseDetections = null;
            draggablePoseLandmarks = [];
            draggedPointInfo = null;

            selectedReferenceFaceIndex = null;
            showFaceLandmarks = false;
            showPoseLandmarks = false;
            resetManualGridState(true);
            resetPreviewVisuals(); // Call this before updateIconStates
            updateIconStates();
        }

        // --- Image Loading (File) ---
        function processImageFile(file) {
            // Don't reset here, reset happens *before* calling this
            if (file && file.type.startsWith('image/')) {
                addComment(`Loading image "${file.name}"...`, 'info');
                const reader = new FileReader();
                reader.onload = (e) => {
                    imagePreview.crossOrigin = "Anonymous";
                    imagePreview.src = e.target.result;
                    imagePreview.onload = () => {
                        currentImageElement = imagePreview;
                        uploadCard.classList.add('hidden'); // Hide upload card
                        newUploadButtonExt.classList.remove('hidden'); // Show external new upload button
                        imagePreviewContainer.classList.remove('hidden'); // Show preview
                        imagePreview.classList.remove('hidden');
                        placeholderText.classList.add('hidden');
                        resizeCanvasToImage();
                        addComment(`Image loaded. Ready for detection or manual grid.`, 'success');
                        updateIconStates();
                    };
                    imagePreview.onerror = () => {
                        addComment(`Error displaying loaded image file.`, 'error');
                        resetFullPreview(); // Reset if image fails to load display
                    };
                }
                reader.onerror = (e) => {
                    addComment(`Error reading image file: ${e.target.error || 'Unknown error'}`, 'error');
                    resetFullPreview();
                };
                reader.readAsDataURL(file);
            } else {
                const message = file ? `Invalid file type: "${file.type}". Only images allowed.` : 'No valid image file provided.';
                addComment(message, 'error');
                resetFullPreview(); // Reset if file is invalid
            }
        }

        // --- Image Loading (URL) ---
        function processImageUrl(url) {
            // Don't reset here, reset happens *before* calling this
            if (!url) {
                addComment('No image URL provided.', 'error');
                resetFullPreview();
                return;
            }

            addComment(`Loading image from URL...`, 'info');

            imagePreview.crossOrigin = "Anonymous";
            imagePreview.src = url;

            imagePreview.onload = () => {
                currentImageElement = imagePreview;
                uploadCard.classList.add('hidden'); // Hide upload card
                newUploadButtonExt.classList.remove('hidden'); // Show external new upload button
                imagePreviewContainer.classList.remove('hidden'); // Show preview
                imagePreview.classList.remove('hidden');
                placeholderText.classList.add('hidden');
                resizeCanvasToImage();
                addComment(`Image from URL loaded. Ready for detection or manual grid.`, 'success');
                try {
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = 1; tempCanvas.height = 1;
                    const tempCtx = tempCanvas.getContext('2d'); tempCtx.drawImage(imagePreview, 0, 0, 1, 1); tempCtx.getImageData(0, 0, 1, 1);
                } catch (e) {
                    if (e.name === "SecurityError") {addComment(`Image loaded, but it's from a different origin without CORS headers. MediaPipe detection might not work.`, 'warning');}
                    else {console.warn("Unexpected error checking canvas taint:", e);}
                }
                updateIconStates();
            };

            imagePreview.onerror = () => {
                addComment(`Error loading image from URL: ${url}. Check the URL and network connection.`, 'error');
                resetFullPreview(); // Reset if URL fails to load
            };
        }


        // Original handler for file input change
        function handleFileInputChange(event) {
            resetCommonState(); // Reset state *before* processing
            const file = event.target.files ? event.target.files[0] : null;
            if (file) {
                processImageFile(file);
            } else {
                addComment('No file selected.', 'info');
                // No need to call resetFullPreview again, resetCommonState did it.
            }
        }

        // Modified resetPreviewVisuals - Controls visibility of upload card vs preview + button
        function resetPreviewVisuals() {
            if (uploadCard) uploadCard.classList.remove('hidden'); // SHOW upload card
            if (imagePreviewContainer) imagePreviewContainer.classList.add('hidden'); // HIDE preview
            if (newUploadButtonExt) newUploadButtonExt.classList.add('hidden'); // HIDE external button
            imagePreview.removeAttribute('src');
            imagePreview.removeAttribute('crossOrigin');
            imagePreview.classList.add('hidden');
            placeholderText.classList.add('hidden');
        }

        function resetFullPreview() {
            resetCommonState(); // Use the common reset function
            if (imageUpload) {imageUpload.value = null;} // Clear file input value
            addComment('Preview reset. Upload a new image or drop it here.', 'info');
        }

        // Resets states related to manual grid definition/adjustment.
        function resetManualGridState(resetConfirmedGrid = false) {
            isDrawingManualGrid = false;
            isAdjustingManualGrid = false;
            manualGridRect = null;
            if (resetConfirmedGrid) {
                finalManualGridRect = null;
                showFinalManualGrid = false;
            }
            adjustmentHandles = [];
            draggedHandleType = null;
            isDraggingGridSquare = false;
            updateAdjustmentHandles();
        }

        // Clears overlays and detection data, including manual grid
        function clearOverlays() {
            addComment('Clearing overlays and detection data...', 'info', 'sketchit');
            // Only clear overlays that are currently active, not the loaded image or preview UI
            let overlaysCleared = false;
            if (showFaceLandmarks) {
                showFaceLandmarks = false;
                lastFaceDetections = null;
                selectedReferenceFaceIndex = null;
                hideFaceSelectionModal();
                overlaysCleared = true;
            }
            if (showPoseLandmarks) {
                showPoseLandmarks = false;
                draggablePoseLandmarks = [];
                lastPoseDetections = null;
                overlaysCleared = true;
            }
            // Manual grid overlays
            if (
                showFinalManualGrid || // If the confirmed manual grid is being shown
                isManualGridModeActive || // If manual grid mode is active (user can start drawing)
                isDrawingManualGrid || // If user is currently drawing the manual grid
                isAdjustingManualGrid || // If user is adjusting the manual grid
                finalManualGridRect // If a confirmed manual grid rectangle exists
            ) {
                resetManualGridState(true);
                isManualGridModeActive = false;
                overlaysCleared = true;
            }
            redrawCanvas();
            updateIconStates();
            if (!overlaysCleared) {
                addComment('No overlays to clear.', 'info');
            }
        }

        // --- UI State & Icon Updates ---
        function updateIconStates() {
            // Only enable landmark/grid icons if an image is loaded AND the preview is visible
            const imageLoadedAndVisible = !!currentImageElement && !imagePreviewContainer.classList.contains('hidden');
            const definingManualGrid = isManualGridModeActive || isDrawingManualGrid || isAdjustingManualGrid;

            // --- Visibility of Upload Card vs Preview ---
            // This logic is now primarily handled in resetCommonState, processImageFile, processImageUrl
            // uploadCard.classList.toggle('hidden', imageLoadedAndVisible);
            // imagePreviewContainer.classList.toggle('hidden', !imageLoadedAndVisible);
            // newUploadButtonExt.classList.toggle('hidden', !imageLoadedAndVisible);


            // Face Icon
            const faceDisabled = !isFaceLandmarkerInitialized || !imageLoadedAndVisible || definingManualGrid;
            iconFace.classList.toggle('disabled', faceDisabled);
            iconFace.classList.toggle('active', showFaceLandmarks && !faceDisabled);
            iconFace.title = faceDisabled ? (imageLoadedAndVisible ? (definingManualGrid ? "Disabled during grid definition" : "Face Landmarker not ready") : "Load an image first") : (showFaceLandmarks ? "Hide Face Landmarks / Grid" : "Show Face Landmarks / Grid");

            // Pose Icon
            const poseDisabled = !isPoseLandmarkerInitialized || !imageLoadedAndVisible || definingManualGrid;
            iconPose.classList.toggle('disabled', poseDisabled);
            iconPose.classList.toggle('active', showPoseLandmarks && !poseDisabled);
            iconPose.title = poseDisabled ? (imageLoadedAndVisible ? (definingManualGrid ? "Disabled during grid definition" : "Pose Landmarker not ready") : "Load an image first") : (showPoseLandmarks ? "Hide Pose Landmarks" : "Show Pose Landmarks");

            // Grid Icon
            const gridDisabled = !imageLoadedAndVisible; // Disable if no image loaded/visible
            iconGrid.classList.toggle('disabled', gridDisabled);
            const gridActive = (definingManualGrid || (showFinalManualGrid && finalManualGridRect)) && !gridDisabled;
            iconGrid.classList.toggle('active', gridActive);
            if (!imageLoadedAndVisible) iconGrid.title = "Load an image first";
            else if (isAdjustingManualGrid) iconGrid.title = "Cancel Grid Adjustment";
            else if (isDrawingManualGrid) iconGrid.title = "Cancel Grid Drawing";
            else if (isManualGridModeActive) iconGrid.title = "Cancel Manual Grid Mode";
            else if (finalManualGridRect) iconGrid.title = showFinalManualGrid ? "Hide Confirmed Grid" : "Show Confirmed Grid";
            else iconGrid.title = "Manually Draw Grid Square";

            // Canvas Cursors & Classes (only apply if image is visible)
            overlayCanvas.classList.remove('manual-grid-drawing', 'manual-grid-adjusting', 'dragging-pose', 'dragging-grid-handle', 'dragging-grid-square', 'point-hover', 'handle-hover', 'square-hover');
            if (imageLoadedAndVisible) {
                if (isDrawingManualGrid) overlayCanvas.classList.add('manual-grid-drawing');
                if (isAdjustingManualGrid) overlayCanvas.classList.add('manual-grid-adjusting');
                if (isDraggingPosePoint) overlayCanvas.classList.add('dragging-pose');
                if (draggedHandleType) overlayCanvas.classList.add('dragging-grid-handle');
                if (isDraggingGridSquare) overlayCanvas.classList.add('dragging-grid-square');
                if (isHoveringPosePoint) overlayCanvas.classList.add('point-hover');
                if (isHoveringGridHandle) overlayCanvas.classList.add('handle-hover');
                if (isHoveringGridSquare) overlayCanvas.classList.add('square-hover');
            }

            // Confirm Button Visibility
            const showConfirm = isAdjustingManualGrid && imageLoadedAndVisible;
            confirmGridButton.classList.toggle('opacity-0', !showConfirm);
            confirmGridButton.classList.toggle('invisible', !showConfirm);
            confirmGridButton.classList.toggle('pointer-events-none', !showConfirm);
            confirmGridButton.classList.toggle('opacity-100', showConfirm);
            confirmGridButton.classList.toggle('visible', showConfirm);
            confirmGridButton.classList.toggle('pointer-events-auto', showConfirm);

            updateAdjustmentHandles();
        }

        // --- Canvas Resizing --- REFINED with LOGGING & FIXES ---
        function resizeCanvasToImage() {
            // Ensure elements exist and image has loaded dimensions
            if (!currentImageElement || !overlayCanvas || !imagePreviewContainer || !currentImageElement.naturalWidth || !currentImageElement.naturalHeight) {
                // Added check for naturalHeight as well for robustness
                console.warn("Resize skipped: Missing elements or zero natural dimensions.");
                return;
            }

            // Capture old canvas drawing surface dimensions BEFORE they are changed
            const oldCanvasDrawingWidth = overlayCanvas.width;
            const oldCanvasDrawingHeight = overlayCanvas.height;

            const img = currentImageElement;
            const canvas = overlayCanvas;
            const container = img.parentElement; // Direct parent: image-display-container

            const cW = container.offsetWidth;
            const cH = container.offsetHeight;

            const imgW = img.naturalWidth;
            const imgH = img.naturalHeight;

            // Check for valid dimensions for both image and container
            if (cW <= 0 || cH <= 0 || imgW <= 0 || imgH <= 0) {
                console.warn(`Resize skipped: Invalid dimensions detected - Container: ${cW}x${cH}, Image: ${imgW}x${imgH}`);
                return;
            }

            console.log(`Resize Start: Container W/H: ${cW}x${cH}, Image Natural W/H: ${imgW}x${imgH}, Old Canvas Draw W/H: ${oldCanvasDrawingWidth}x${oldCanvasDrawingHeight}`);
            let rW, rH, oX, oY;
            // --- CORRECTED rW, rH CALCULATION for object-fit: contain ---
            let finalScale;
            // Always scale the to fit the container (object-fit: contain)
            finalScale = Math.min(cW / imgW, cH / imgH);
            img.style.width = `${imgW * finalScale}px`;
            img.style.height = `${imgH * finalScale}px`;
            img.style.objectFit = 'contain';
            console.log(`Resize Scale: ${finalScale.toFixed(3)}`);

            rW = imgW * finalScale;
            rH = imgH * finalScale;

            // Calculate offsets to center the (potentially letterboxed/pillarboxed) image within the container.
            // The container itself uses flexbox to center its <img> child, but we need these
            // offsets to position our canvas overlay correctly over the actual image content.
            oX = (cW - rW) / 2;
            oY = (cH - rH) / 2;
            // --- END CORRECTED rW, rH CALCULATION ---


            // Ensure calculated dimensions are valid numbers (especially after multiplication by finalScale)
            if (isNaN(rW) || isNaN(rH) || isNaN(oX) || isNaN(oY)) {
                console.error("Resize Error: Calculated NaN values for rW, rH, oX, or oY.", {rW, rH, oX, oY, finalScale});
                return;
            }
            // Ensure rW and rH are not negative or extremely small due to float precision with finalScale
            rW = Math.max(0, rW);
            rH = Math.max(0, rH);


            const newCanvasDrawingWidth = rW;
            const newCanvasDrawingHeight = rH;

            console.log(`Resize Calculated: finalScale=${finalScale.toFixed(3)}, Rendered Img W/H: ${rW.toFixed(1)}x${rH.toFixed(1)}, Offset X/Y: ${oX.toFixed(1)}x${oY.toFixed(1)}, New Canvas Draw W/H: ${newCanvasDrawingWidth}x${newCanvasDrawingHeight}`);

            // Apply size and position to canvas FIRST
            canvas.width = newCanvasDrawingWidth;
            canvas.height = newCanvasDrawingHeight;
            canvas.style.width = `${newCanvasDrawingWidth}px`;
            canvas.style.height = `${newCanvasDrawingHeight}px`;
            canvas.style.left = `${oX}px`;
            canvas.style.top = `${oY}px`;

            // Apply size and position to adjustment handles container
            adjustmentHandlesContainer.style.left = `${oX}px`;
            adjustmentHandlesContainer.style.top = `${oY}px`;
            adjustmentHandlesContainer.style.width = `${newCanvasDrawingWidth}px`;
            adjustmentHandlesContainer.style.height = `${newCanvasDrawingHeight}px`;

            console.log(`Resize Applied: Canvas W/H: ${canvas.width}x${canvas.height}, Style W/H: ${canvas.style.width}x${canvas.style.height}, Style L/T: ${canvas.style.left}x${canvas.style.top}`);

            // --- START: MODIFIED POSE LANDMARK HANDLING ---
            if (oldCanvasDrawingWidth > 0 && oldCanvasDrawingHeight > 0 && draggablePoseLandmarks.length > 0 && newCanvasDrawingWidth > 0) {
                const scaleFactor = newCanvasDrawingWidth / oldCanvasDrawingWidth;
                if (Math.abs(scaleFactor - 1.0) > 0.0001 || oldCanvasDrawingWidth !== newCanvasDrawingWidth || oldCanvasDrawingHeight !== newCanvasDrawingHeight) {
                    console.log(`Scaling existing draggablePoseLandmarks (multiple poses) by ${scaleFactor.toFixed(3)}.`);
                    // MODIFICATION: Iterate through each pose and its landmarks
                    draggablePoseLandmarks.forEach((singlePoseLandmarks, poseIndex) => {
                        singlePoseLandmarks.forEach((landmark, landmarkIndex) => {
                            const oldX = landmark.x;
                            const oldY = landmark.y;
                            landmark.x *= scaleFactor;
                            landmark.y *= scaleFactor;
                            if (poseIndex === 0 && landmarkIndex === 0 && landmark.x !== undefined) { // Log first point of first pose
                                console.log(`Scaled Pose ${poseIndex} Lm ${landmarkIndex}: Old (${oldX.toFixed(1)}, ${oldY.toFixed(1)}) -> New (${landmark.x.toFixed(1)}, ${landmark.y.toFixed(1)})`);
                            }
                        });
                    });
                } else {
                    console.log("Pose landmarks (multiple): No significant scaling needed.");
                }
            } else if (lastPoseDetections?.landmarks?.length > 0 && newCanvasDrawingWidth > 0 && newCanvasDrawingHeight > 0) {
                console.log(`Resize: Initializing draggable pose landmarks (multiple) from lastPoseDetections. Canvas W/H: ${newCanvasDrawingWidth}x${newCanvasDrawingHeight}`);
                // MODIFICATION: Iterate through each pose and its landmarks from lastPoseDetections
                draggablePoseLandmarks = lastPoseDetections.landmarks.map((poseLandmarksArray, poseIndexOuter) => {
                    return poseLandmarksArray.map((lm, landmarkIndexOuter) => {
                        const pixelX = lm.x * newCanvasDrawingWidth;
                        const pixelY = lm.y * newCanvasDrawingHeight;
                        if (poseIndexOuter === 0 && landmarkIndexOuter === 0 && pixelX !== undefined) { // Log first point of first pose
                            console.log(`Resize Initial Calc (Pose ${poseIndexOuter}, Lm ${landmarkIndexOuter}): Norm (${lm.x.toFixed(3)}, ${lm.y.toFixed(3)}) -> Pixel (${pixelX.toFixed(1)}, ${pixelY.toFixed(1)})`);
                        }
                        return {x: pixelX, y: pixelY, visibility: lm.visibility};
                    });
                });
            } else {
                draggablePoseLandmarks = [];
            }
            // --- END: MODIFIED POSE LANDMARK HANDLING ---


            // ---- START: SCALING FOR MANUAL GRIDS ----
            if (oldCanvasDrawingWidth > 0 && oldCanvasDrawingHeight > 0 && newCanvasDrawingWidth > 0) { // Added newCanvasDrawingWidth > 0 for scaleFactor safety
                const scaleFactor = newCanvasDrawingWidth / oldCanvasDrawingWidth;
                // Check if scaling is significant
                if (Math.abs(scaleFactor - 1.0) > 0.0001 || oldCanvasDrawingWidth !== newCanvasDrawingWidth || oldCanvasDrawingHeight !== newCanvasDrawingHeight) {
                    if (manualGridRect && manualGridRect.size > 0) {
                        console.log(`Scaling manualGridRect by ${scaleFactor.toFixed(3)}. Old: x=${manualGridRect.x.toFixed(1)}, y=${manualGridRect.y.toFixed(1)}, size=${manualGridRect.size.toFixed(1)}`);
                        manualGridRect.x *= scaleFactor;
                        manualGridRect.y *= scaleFactor;
                        manualGridRect.size *= scaleFactor;
                        console.log(`New manualGridRect: x=${manualGridRect.x.toFixed(1)}, y=${manualGridRect.y.toFixed(1)}, size=${manualGridRect.size.toFixed(1)}`);

                        if (isAdjustingManualGrid) {
                            calculateAndUpdateHandlePositions();
                        }
                    }

                    if (finalManualGridRect && finalManualGridRect.size > 0) {
                        console.log(`Scaling finalManualGridRect by ${scaleFactor.toFixed(3)}. Old: x=${finalManualGridRect.x.toFixed(1)}, y=${finalManualGridRect.y.toFixed(1)}, size=${finalManualGridRect.size.toFixed(1)}`);
                        finalManualGridRect.x *= scaleFactor;
                        finalManualGridRect.y *= scaleFactor;
                        finalManualGridRect.size *= scaleFactor;
                        console.log(`New finalManualGridRect: x=${finalManualGridRect.x.toFixed(1)}, y=${finalManualGridRect.y.toFixed(1)}, size=${finalManualGridRect.size.toFixed(1)}`);
                    }

                    if (isDrawingManualGrid) {
                        console.log(`Scaling in-progress manual grid draw points by ${scaleFactor.toFixed(3)}`);
                        manualGridStartX *= scaleFactor;
                        manualGridStartY *= scaleFactor;
                        manualGridCurrentX *= scaleFactor;
                        manualGridCurrentY *= scaleFactor;
                    }
                } else {
                    console.log("Manual grids: No significant scaling needed.");
                }
            }
            // ---- END: SCALING FOR MANUAL GRIDS ----

            redrawCanvas();
            updateIconStates();
        }
        // --- Central Drawing Function ---
        // ... (Unchanged: redrawCanvas) ...
        function redrawCanvas() {
            clearCanvas();
            if (showFaceLandmarks && lastFaceDetections && !isManualGridModeActive && !isDrawingManualGrid && !isAdjustingManualGrid) {
                drawFaceLandmarksInternal(lastFaceDetections, selectedReferenceFaceIndex);
            }
            if (showPoseLandmarks && draggablePoseLandmarks.length > 0 && !isManualGridModeActive && !isDrawingManualGrid && !isAdjustingManualGrid) {
                drawPoseLandmarksInternal();
            }
            if (isDrawingManualGrid) {drawManualGridSelection();}
            else if (isAdjustingManualGrid && manualGridRect) {drawAdjustableGridSquare();}
            else if (showFinalManualGrid && finalManualGridRect) {drawGridFromRect(finalManualGridRect);}
            updateIconStates();
        }

        // --- Face Detection & Drawing ---
        // ... (Unchanged: showFaceSelectionModal, hideFaceSelectionModal, handleFaceSelection, drawFaceLandmarksInternal, handleFaceIconClick) ...
        function showFaceSelectionModal(numFaces) {
            modalFaceButtons.innerHTML = ''; for (let i = 0; i < numFaces; i++) {const b = document.createElement('button'); b.textContent = `Face ${i + 1}`; b.classList.add('select-face-btn'); b.dataset.index = i; b.addEventListener('click', handleFaceSelection); modalFaceButtons.appendChild(b);} faceSelectionModal.classList.add('visible');
        }
        function hideFaceSelectionModal() {faceSelectionModal.classList.remove('visible');}
        function handleFaceSelection(event) {
            const idx = parseInt(event.target.dataset.index, 10); selectedReferenceFaceIndex = idx; addComment(`Selected Face ${idx + 1} for grid.`, 'success', 'User'); hideFaceSelectionModal(); redrawCanvas();
        }
        function drawFaceLandmarksInternal(results, gridFaceIndex = null) {
            if (!results?.faceLandmarks || !drawingUtils || results.faceLandmarks.length === 0) return;
            results.faceLandmarks.forEach((landmarks, index) => {
                const isSelected = index === gridFaceIndex;
                const eyeC = isSelected ? "#FF3030" : "#FFA0A0", lipC = isSelected ? "#E0E0E0" : "#B0B0B0", ovalC = isSelected ? "#E0E0E0" : "#B0B0B0";
                if (landmarks?.length > 0) {
                    try {
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE, {color: eyeC, lineWidth: 1});
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE, {color: eyeC, lineWidth: 1});
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL, {color: ovalC, lineWidth: 1});
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_LIPS, {color: lipC, lineWidth: 1});
                    } catch (e) {if (isSelected) addComment(`Error drawing basic landmarks for Face ${index + 1}.`, 'error');}
                } else {if (isSelected) addComment(`No landmarks for selected Face ${index + 1}.`, 'info'); return;}

                if (isSelected) {
                    const pxLm = landmarks.map(p => ({x: p.x * overlayCanvas.width, y: p.y * overlayCanvas.height}));
                    let fMinX = Infinity, fMaxX = -Infinity, fMinY = Infinity, fMaxY = -Infinity;
                    pxLm.forEach(p => {fMinX = Math.min(fMinX, p.x); fMaxX = Math.max(fMaxX, p.x); fMinY = Math.min(fMinY, p.y); fMaxY = Math.max(fMaxY, p.y);});
                    let fWidth = fMaxX - fMinX, fHeight = fMaxY - fMinY;
                    let gridSize = Math.max(fWidth, fHeight);
                    if (gridSize > 0) {
                        let fMidX = (fMinX + fMaxX) / 2, fMidY = (fMinY + fMaxY) / 2;
                        let gridStartX = fMidX - gridSize / 2, gridStartY = fMidY - gridSize / 2;
                        drawGridFromRect({x: gridStartX, y: gridStartY, size: gridSize});
                    } else {addComment(`Could not determine size for face grid for Face ${index + 1}.`, 'warning');}
                }
            });
        }
        // --- Face Icon Click Handler --- MODIFIED with LOGGING ---
        function handleFaceIconClick() {
            if (!isFaceLandmarkerInitialized || !faceLandmarker || !currentImageElement || iconFace.classList.contains('disabled')) return;
            showFaceLandmarks = !showFaceLandmarks;
            if (showFaceLandmarks) {
                addComment('Showing face landmarks/grid...', 'info');
                if (!lastFaceDetections) {
                    addComment('Running face detection...', 'info');
                    try {
                        console.log(`Running face detection on image: ${currentImageElement.src.substring(0, 100)}...`); // Log source
                        const results = faceLandmarker.detect(currentImageElement);
                        const numFaces = results.faceLandmarks.length;
                        if (numFaces > 0) {
                            addComment(`Found ${numFaces} face(s).`, 'success');
                            lastFaceDetections = results;
                            if (numFaces > 1) {
                                selectedReferenceFaceIndex = null;
                                addComment(`Select face for grid.`, 'info');
                                showFaceSelectionModal(numFaces);
                                return; // Wait for selection
                            } else {
                                selectedReferenceFaceIndex = 0;
                            }
                        } else {
                            addComment('No faces detected.', 'info');
                            lastFaceDetections = null;
                            showFaceLandmarks = false; // Turn off if no faces found
                        }
                    } catch (error) {
                        addComment(`Face detection failed: ${error}`, 'error');
                        console.error("Face detection error:", error); // Log the full error
                        lastFaceDetections = null;
                        showFaceLandmarks = false; // Turn off on error
                    }
                } else if (lastFaceDetections.faceLandmarks.length > 1 && selectedReferenceFaceIndex === null) {
                    addComment(`Select face for grid.`, 'info');
                    showFaceSelectionModal(lastFaceDetections.faceLandmarks.length);
                    return; // Wait for selection
                }
                redrawCanvas(); // Redraw only if detection ran or selection exists
            } else {
                addComment('Hiding face landmarks/grid.', 'info');
                hideFaceSelectionModal();
                redrawCanvas(); // Redraw without landmarks
            }
            updateIconStates();
        }


// --- Pose Icon Click Handler --- MODIFIED with LOGGING & MULTI-POSE ---
function handlePoseIconClick() {
    if (!isPoseLandmarkerInitialized || !poseLandmarker || !currentImageElement || iconPose.classList.contains('disabled')) return;
    showPoseLandmarks = !showPoseLandmarks;
    if (showPoseLandmarks) {
        addComment('Showing pose landmarks...', 'info');
        if (!lastPoseDetections) { // Detect only if no data
            addComment('Running pose detection...', 'info');
            try {
                console.log(`Running pose detection on image: ${currentImageElement.src.substring(0, 100)}...`);
                const results = poseLandmarker.detect(currentImageElement);
                if (results.landmarks.length > 0) {
                    // MODIFICATION: Update comment for multiple poses
                    addComment(`Found ${results.landmarks.length} pose(s).`, 'success');
                    lastPoseDetections = results;
                    console.log(`Initial Pose Calc: Using canvas W/H: ${overlayCanvas.width}x${overlayCanvas.height}`);
                    // MODIFICATION: Process all detected poses
                    draggablePoseLandmarks = results.landmarks.map((singlePoseLms, poseIdx) => {
                        return singlePoseLms.map((lm, lmIdx) => {
                            const pixelX = lm.x * overlayCanvas.width;
                            const pixelY = lm.y * overlayCanvas.height;
                            if (poseIdx === 0 && lmIdx === 0) { // Log first point of first pose
                                console.log(`Initial Calc Pose 0, Lm 0: Norm (${lm.x.toFixed(3)}, ${lm.y.toFixed(3)}) -> Pixel (${pixelX.toFixed(1)}, ${pixelY.toFixed(1)})`);
                            }
                            return { x: pixelX, y: pixelY, visibility: lm.visibility };
                        });
                    });
                } else {
                    addComment('No poses detected.', 'info');
                    lastPoseDetections = null;
                    draggablePoseLandmarks = [];
                    showPoseLandmarks = false;
                }
            } catch (error) {
                addComment(`Pose detection failed: ${error}`, 'error');
                console.error("Pose detection error:", error);
                lastPoseDetections = null;
                draggablePoseLandmarks = [];
                showPoseLandmarks = false;
            }
        } else if (draggablePoseLandmarks.length === 0 && lastPoseDetections?.landmarks?.length > 0) {
            addComment('Restoring previous pose data...', 'info');
            console.log(`Restore Pose Calc: Using canvas W/H: ${overlayCanvas.width}x${overlayCanvas.height}`);
            // MODIFICATION: Process all detected poses from lastDetections
            draggablePoseLandmarks = lastPoseDetections.landmarks.map((singlePoseLms, poseIdx) => {
                return singlePoseLms.map((lm, lmIdx) => {
                    const pixelX = lm.x * overlayCanvas.width;
                    const pixelY = lm.y * overlayCanvas.height;
                    if (poseIdx === 0 && lmIdx === 0) {
                         console.log(`Restore Calc Pose 0, Lm 0: Norm (${lm.x.toFixed(3)}, ${lm.y.toFixed(3)}) -> Pixel (${pixelX.toFixed(1)}, ${pixelY.toFixed(1)})`);
                    }
                    return { x: pixelX, y: pixelY, visibility: lm.visibility };
                });
            });
        }
        redrawCanvas();
    } else {
        addComment('Hiding pose landmarks.', 'info');
        redrawCanvas();
    }
    updateIconStates();
}

        function drawPoseLandmarksInternal() {
            if (!draggablePoseLandmarks || draggablePoseLandmarks.length === 0 || !drawingUtils) return;
            const connections = PoseLandmarker.POSE_CONNECTIONS;
            if (!connections) {console.error("Pose connections not available."); return;}

            // MODIFICATION: Iterate through each pose in draggablePoseLandmarks
            draggablePoseLandmarks.forEach((singlePoseLandmarks, poseDrawingIdx) => {
                if (!singlePoseLandmarks || singlePoseLandmarks.length === 0) return; // Skip if a pose has no landmarks

                // You can assign different colors per pose if desired, e.g., based on poseDrawingIdx
                const poseColor = ['#00FF00', '#00FFFF', '#FF00FF'][poseDrawingIdx % 3] || '#00FF00'; // Example: cycle colors
                const pointColor = ['#FF0000', '#FFFF00', '#0000FF'][poseDrawingIdx % 3] || '#FF0000';

                canvasCtx.strokeStyle = poseColor;
                canvasCtx.lineWidth = 2;
                connections.forEach((c) => {
                    const sIdx = c.start, eIdx = c.end;
                    if (sIdx <= 10 || eIdx <= 10) return; // Skip face landmarks (indices 0-10 are typically face)
                    if (sIdx < singlePoseLandmarks.length && eIdx < singlePoseLandmarks.length) {
                        const sP = singlePoseLandmarks[sIdx], eP = singlePoseLandmarks[eIdx];
                        // Ensure points are valid before drawing
                        if (sP && eP && typeof sP.x === 'number' && typeof sP.y === 'number' && typeof eP.x === 'number' && typeof eP.y === 'number') {
                            canvasCtx.beginPath(); canvasCtx.moveTo(sP.x, sP.y); canvasCtx.lineTo(eP.x, eP.y); canvasCtx.stroke();
                        }
                    }
                });

                canvasCtx.fillStyle = pointColor;
                singlePoseLandmarks.forEach((p, landmarkDrawingIdx) => {
                    if (landmarkDrawingIdx <= 10) return; // Skip face points
                    // Ensure point is valid
                    if (p && typeof p.x === 'number' && typeof p.y === 'number') {
                        canvasCtx.beginPath(); canvasCtx.arc(p.x, p.y, pointRadius, 0, 2 * Math.PI); canvasCtx.fill();

                        // MODIFICATION: Highlight dragged point using draggedPointInfo
                        if (isDraggingPosePoint && draggedPointInfo &&
                            draggedPointInfo.poseIndex === poseDrawingIdx &&
                            draggedPointInfo.pointIndex === landmarkDrawingIdx) {
                            canvasCtx.strokeStyle = '#0000FF'; // Highlight color for dragged point
                            canvasCtx.lineWidth = 2;           // Make highlight distinct
                            canvasCtx.stroke();                // Draw the highlight circle
                        }
                    }
                });
            });
        }


        // --- Manual Grid Drawing & Adjustment ---
        // ... (Unchanged: handleGridIconClick, drawManualGridSelection, drawAdjustableGridSquare, calculateAndUpdateHandlePositions, updateAdjustmentHandles, drawGridFromRect) ...
        function handleGridIconClick() {
            if (!currentImageElement || iconGrid.classList.contains('disabled')) return;
            if (finalManualGridRect) {
                showFinalManualGrid = !showFinalManualGrid;
                addComment(showFinalManualGrid ? 'Showing confirmed manual grid.' : 'Hiding confirmed manual grid.', 'info');
                isManualGridModeActive = false; isDrawingManualGrid = false; isAdjustingManualGrid = false;
                manualGridRect = null; adjustmentHandles = []; updateAdjustmentHandles();
            } else {
                isManualGridModeActive = !isManualGridModeActive;
                if (isManualGridModeActive) {
                    addComment('Manual Grid Mode: Click and drag on the image to define the grid square.', 'info', 'User');
                    resetManualGridState(false);
                } else {
                    if (isAdjustingManualGrid) {addComment('Manual grid adjustment cancelled.', 'info');}
                    else if (isDrawingManualGrid) {addComment('Manual grid drawing cancelled.', 'info');}
                    else {addComment('Exiting manual grid mode.', 'info');}
                    resetManualGridState(false);
                }
            }
            updateIconStates();
        }
        function drawManualGridSelection() {
            if (!isDrawingManualGrid) return;
            const width = manualGridCurrentX - manualGridStartX; const height = manualGridCurrentY - manualGridStartY;
            const size = Math.max(Math.abs(width), Math.abs(height));
            const endX = manualGridStartX + (width >= 0 ? size : -size); const endY = manualGridStartY + (height >= 0 ? size : -size);
            canvasCtx.strokeStyle = 'rgba(255, 0, 255, 0.8)'; canvasCtx.lineWidth = 2;
            canvasCtx.setLineDash([5, 5]);
            canvasCtx.strokeRect(manualGridStartX, manualGridStartY, endX - manualGridStartX, endY - manualGridStartY);
            canvasCtx.setLineDash([]);
        }
        function drawAdjustableGridSquare() {
            if (!manualGridRect || manualGridRect.size <= 0) return;
            const {x, y, size} = manualGridRect;
            canvasCtx.strokeStyle = 'rgba(255, 0, 255, 0.9)'; canvasCtx.lineWidth = 2;
            canvasCtx.strokeRect(x, y, size, size);
        }
        function calculateAndUpdateHandlePositions() {
            adjustmentHandles = [];
            if (!manualGridRect || !isAdjustingManualGrid) {updateAdjustmentHandles(); return;}
            const {x, y, size} = manualGridRect; const halfSize = size / 2;
            adjustmentHandles = [
                {type: 'tl', x: x, y: y}, {type: 'tr', x: x + size, y: y}, {type: 'bl', x: x, y: y + size}, {type: 'br', x: x + size, y: y + size},
                {type: 'tm', x: x + halfSize, y: y}, {type: 'bm', x: x + halfSize, y: y + size}, {type: 'ml', x: x, y: y + halfSize}, {type: 'mr', x: x + size, y: y + halfSize}
            ];
            updateAdjustmentHandles();
        }
        function updateAdjustmentHandles() {
            adjustmentHandlesContainer.innerHTML = '';
            if (!isAdjustingManualGrid || !manualGridRect) return;
            adjustmentHandles.forEach(handle => {
                const handleElement = document.createElement('div');
                handleElement.className = 'adjustment-handle';
                handleElement.style.left = `${handle.x}px`; handleElement.style.top = `${handle.y}px`;
                handleElement.dataset.type = handle.type;
                adjustmentHandlesContainer.appendChild(handleElement);
            });
        }
        function drawGridFromRect(gridRect) {
            if (!gridRect || gridRect.size <= 0) return;
            const {x: startX, y: startY, size} = gridRect;
            const endX = startX + size; const endY = startY + size;
            const canvasWidth = overlayCanvas.width; const canvasHeight = overlayCanvas.height;
            canvasCtx.lineWidth = 1;

            // Vertical Lines (Cyan)
            canvasCtx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            for (let currentX = startX; currentX < canvasWidth + size; currentX += size) {if (currentX >= -size && size > 0) {canvasCtx.beginPath(); canvasCtx.moveTo(currentX, 0); canvasCtx.lineTo(currentX, canvasHeight); canvasCtx.stroke();} if (size === 0) break;}
            for (let currentX = startX - size; currentX > -size; currentX -= size) {if (currentX < canvasWidth + size && size > 0) {canvasCtx.beginPath(); canvasCtx.moveTo(currentX, 0); canvasCtx.lineTo(currentX, canvasHeight); canvasCtx.stroke();} if (size === 0) break;}

            // Horizontal Lines (Yellow)
            canvasCtx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            for (let currentY = startY; currentY < canvasHeight + size; currentY += size) {if (currentY >= -size && size > 0) {canvasCtx.beginPath(); canvasCtx.moveTo(0, currentY); canvasCtx.lineTo(canvasWidth, currentY); canvasCtx.stroke();} if (size === 0) break;}
            for (let currentY = startY - size; currentY > -size; currentY -= size) {if (currentY < canvasHeight + size && size > 0) {canvasCtx.beginPath(); canvasCtx.moveTo(0, currentY); canvasCtx.lineTo(canvasWidth, currentY); canvasCtx.stroke();} if (size === 0) break;}

            // Inner Thirds Lines
            if (size > 0) {
                const thirdSize = size / 3;
                canvasCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)'; // Green
                canvasCtx.beginPath(); canvasCtx.moveTo(startX + thirdSize, startY); canvasCtx.lineTo(startX + thirdSize, endY); canvasCtx.stroke();
                canvasCtx.beginPath(); canvasCtx.moveTo(startX + 2 * thirdSize, startY); canvasCtx.lineTo(startX + 2 * thirdSize, endY); canvasCtx.stroke();
                canvasCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; // Red
                canvasCtx.beginPath(); canvasCtx.moveTo(startX, startY + thirdSize); canvasCtx.lineTo(endX, startY + thirdSize); canvasCtx.stroke();
                canvasCtx.beginPath(); canvasCtx.moveTo(startX, startY + 2 * thirdSize); canvasCtx.lineTo(endX, startY + 2 * thirdSize); canvasCtx.stroke();
            }

            // Defining square outline
            canvasCtx.strokeStyle = 'rgba(255, 0, 255, 0.9)'; canvasCtx.lineWidth = 2;
            canvasCtx.strokeRect(startX, startY, size, size);
        }

        // --- Mouse/Touch Interaction Logic ---
        // ... (Unchanged: getMousePos, handleMouseDown, handleMouseMove, handleMouseUp) ...
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {x: clientX - rect.left, y: clientY - rect.top};
        }
        function handleMouseDown(e) {
            const pos = getMousePos(overlayCanvas, e); let interactionStarted = false;
            if (isAdjustingManualGrid) {
                let handleClicked = false;
                for (const handle of adjustmentHandles) {
                    const dx = pos.x - handle.x; const dy = pos.y - handle.y;
                    if (dx * dx + dy * dy < handleHitRadius * handleHitRadius) {
                        draggedHandleType = handle.type; isDraggingGridSquare = false;
                        gridDragStartX = manualGridRect.x; gridDragStartY = manualGridRect.y;
                        manualGridCurrentX = pos.x; manualGridCurrentY = pos.y;
                        handleClicked = true; interactionStarted = true; break;
                    }
                }
                if (!handleClicked && manualGridRect) {
                    const {x, y, size} = manualGridRect;
                    if (pos.x >= x && pos.x <= x + size && pos.y >= y && pos.y <= y + size) {
                        isDraggingGridSquare = true; draggedHandleType = null;
                        dragOffsetX = pos.x - x; dragOffsetY = pos.y - y;
                        interactionStarted = true;
                    }
                }
            } else if (isManualGridModeActive && !isDrawingManualGrid) {
                isDrawingManualGrid = true;
                manualGridStartX = pos.x; manualGridStartY = pos.y;
                manualGridCurrentX = pos.x; manualGridCurrentY = pos.y;
                manualGridRect = null; interactionStarted = true;
            } else if (showPoseLandmarks && draggablePoseLandmarks.length > 0) {
                for (let poseIdx = 0; poseIdx < draggablePoseLandmarks.length; poseIdx++) {
                    const singlePoseLandmarks = draggablePoseLandmarks[poseIdx];
                    for (let lmIdx = 0; lmIdx < singlePoseLandmarks.length; lmIdx++) {
                        if (lmIdx <= 10) continue; // Skip face points
                        const p = singlePoseLandmarks[lmIdx];
                        if (!p || typeof p.x !== 'number' || typeof p.y !== 'number') continue; // Skip invalid points

                        const dx = pos.x - p.x; const dy = pos.y - p.y;
                        if (dx * dx + dy * dy < hitRadius * hitRadius) {
                            isDraggingPosePoint = true;
                            // MODIFICATION: Store pose and point index
                            draggedPointInfo = {poseIndex: poseIdx, pointIndex: lmIdx};
                            dragOffsetX = dx; dragOffsetY = dy;
                            interactionStarted = true;
                            break; // Found a point in this pose
                        }
                    }
                    if (interactionStarted) break; // Found a point, stop checking other poses
                }
            }
            if (interactionStarted) {if (e.touches) e.preventDefault(); redrawCanvas();}
        }
        function handleMouseMove(e) {
            const isDragging = draggedHandleType || isDraggingGridSquare || isDrawingManualGrid || isDraggingPosePoint;
            if (isDragging && e.touches) e.preventDefault();
            const pos = getMousePos(overlayCanvas, e);
            isHoveringPosePoint = false; isHoveringGridHandle = false; isHoveringGridSquare = false;

            if (draggedHandleType && isAdjustingManualGrid && manualGridRect) {
                const currentX = pos.x; const currentY = pos.y;
                let {x, y, size} = manualGridRect; let newX = x, newY = y, newSize = size;
                const rightEdge = x + size; const bottomEdge = y + size;
                switch (draggedHandleType) {
                    case 'tl': const dX_tl = rightEdge - currentX; const dY_tl = bottomEdge - currentY; newSize = Math.max(dX_tl, dY_tl, MIN_GRID_SIZE); newX = rightEdge - newSize; newY = bottomEdge - newSize; break;
                    case 'tr': const dX_tr = currentX - x; const dY_tr = bottomEdge - currentY; newSize = Math.max(dX_tr, dY_tr, MIN_GRID_SIZE); newY = bottomEdge - newSize; break;
                    case 'bl': const dX_bl = rightEdge - currentX; const dY_bl = currentY - y; newSize = Math.max(dX_bl, dY_bl, MIN_GRID_SIZE); newX = rightEdge - newSize; break;
                    case 'br': const dX_br = currentX - x; const dY_br = currentY - y; newSize = Math.max(dX_br, dY_br, MIN_GRID_SIZE); break;
                    case 'tm': newSize = Math.max(bottomEdge - currentY, MIN_GRID_SIZE); const sCY_tm = size - newSize; newX = x + sCY_tm / 2; newY = bottomEdge - newSize; break;
                    case 'bm': newSize = Math.max(currentY - y, MIN_GRID_SIZE); const sCY_bm = size - newSize; newX = x + sCY_bm / 2; break;
                    case 'ml': newSize = Math.max(rightEdge - currentX, MIN_GRID_SIZE); const sCX_ml = size - newSize; newX = rightEdge - newSize; newY = y + sCX_ml / 2; break;
                    case 'mr': newSize = Math.max(currentX - x, MIN_GRID_SIZE); const sCX_mr = size - newSize; newY = y + sCX_mr / 2; break;
                }
                manualGridRect = {x: newX, y: newY, size: newSize};
                calculateAndUpdateHandlePositions(); requestAnimationFrame(redrawCanvas);
            } else if (isDraggingGridSquare && isAdjustingManualGrid && manualGridRect) {
                manualGridRect.x = pos.x - dragOffsetX; manualGridRect.y = pos.y - dragOffsetY;
                manualGridRect.x = Math.max(0, Math.min(overlayCanvas.width - manualGridRect.size, manualGridRect.x));
                manualGridRect.y = Math.max(0, Math.min(overlayCanvas.height - manualGridRect.size, manualGridRect.y));
                calculateAndUpdateHandlePositions(); requestAnimationFrame(redrawCanvas);
            } else if (isDrawingManualGrid) {
                manualGridCurrentX = pos.x; manualGridCurrentY = pos.y;
                requestAnimationFrame(redrawCanvas);
            } else if (isDraggingPosePoint && draggedPointInfo) {
                const dP = draggablePoseLandmarks[draggedPointInfo.poseIndex][draggedPointInfo.pointIndex];
                if (dP) {
                    dP.x = pos.x - dragOffsetX; dP.y = pos.y - dragOffsetY;
                    dP.x = Math.max(0, Math.min(overlayCanvas.width, dP.x));
                    dP.y = Math.max(0, Math.min(overlayCanvas.height, dP.y));
                    requestAnimationFrame(redrawCanvas);
                }
            } else {
                const definingManualGrid = isManualGridModeActive || isDrawingManualGrid || isAdjustingManualGrid;

                if (showPoseLandmarks && !definingManualGrid) {
                    for (let i = 0; i < draggablePoseLandmarks.length; i++) {if (i <= 10) continue; const p = draggablePoseLandmarks[i]; const dx = pos.x - p.x; const dy = pos.y - p.y; if (dx * dx + dy * dy < hitRadius * hitRadius) {isHoveringPosePoint = true; break;} }
                }
                if (isAdjustingManualGrid && manualGridRect) {
                    for (const handle of adjustmentHandles) {const dx = pos.x - handle.x; const dy = pos.y - handle.y; if (dx * dx + dy * dy < handleHitRadius * handleHitRadius) {isHoveringGridHandle = true; break;} }
                    if (!isHoveringGridHandle) {const {x, y, size} = manualGridRect; if (pos.x >= x && pos.x <= x + size && pos.y >= y && pos.y <= y + size) {isHoveringGridSquare = true;} }
                }
                updateIconStates();
            }
        }
        function handleMouseUp(e) {
            if (draggedHandleType || isDraggingGridSquare) {
                draggedHandleType = null; isDraggingGridSquare = false; redrawCanvas();
            } else if (isDrawingManualGrid) {
                isDrawingManualGrid = false;
                const width = manualGridCurrentX - manualGridStartX; const height = manualGridCurrentY - manualGridStartY;
                let size = Math.max(Math.abs(width), Math.abs(height));
                if (size >= MIN_GRID_SIZE) {
                    const finalStartX = width >= 0 ? manualGridStartX : manualGridStartX - size;
                    const finalStartY = height >= 0 ? manualGridStartY : manualGridStartY - size;
                    manualGridRect = {x: finalStartX, y: finalStartY, size: size};
                    isAdjustingManualGrid = true;
                    addComment(`Grid square drawn. Adjust size/position and click Confirm.`, 'info', 'User');
                    calculateAndUpdateHandlePositions();
                } else {
                    addComment(`Manual grid square too small (min ${MIN_GRID_SIZE}px), cancelled.`, 'warning');
                    manualGridRect = null; isManualGridModeActive = false;
                }
                redrawCanvas(); updateIconStates();
            } else if (isDraggingPosePoint) {
                isDraggingPosePoint = false;
                draggedPointInfo = null;
                dragOffsetX = 0; dragOffsetY = 0;
                redrawCanvas(); updateIconStates();
            }
        }

        // --- Confirm Grid Button Handler ---
        // ... (Unchanged: handleConfirmGrid) ...
        function handleConfirmGrid() {
            if (!isAdjustingManualGrid || !manualGridRect) return;
            addComment('Manual grid confirmed.', 'success', 'User');
            finalManualGridRect = {...manualGridRect};
            showFinalManualGrid = true;
            isAdjustingManualGrid = false; isManualGridModeActive = false;
            resetManualGridState(false);
            redrawCanvas(); updateIconStates();
        }

        // --- Drag and Drop Event Handlers for Body ---
        // ... (Unchanged: handleDragOver, handleDragLeave, handleDrop) ...
        function handleDragOver(event) {
            event.preventDefault(); event.stopPropagation();
            const dt = event.dataTransfer;
            if (dt.types.includes('Files') || dt.types.includes('text/uri-list') || dt.types.includes('text/html')) {
                bodyElement.classList.add('dragover'); dt.dropEffect = 'copy';
            } else {dt.dropEffect = 'none';}
        }
        function handleDragLeave(event) {
            event.preventDefault(); event.stopPropagation();
            if (!bodyElement.contains(event.relatedTarget)) {bodyElement.classList.remove('dragover');}
        }
        function handleDrop(event) {
            event.preventDefault(); event.stopPropagation(); bodyElement.classList.remove('dragover');
            resetCommonState(); // Reset state *before* processing drop
            const dt = event.dataTransfer; const files = dt.files; let processed = false;
            if (files.length > 0) {
                for (let i = 0; i < files.length; i++) {if (files[i].type.startsWith('image/')) {processImageFile(files[i]); processed = true; break;} }
            }
            if (!processed && dt.types.includes('text/uri-list')) {
                const uriList = dt.getData('text/uri-list'); const lines = uriList.split('\n');
                for (const line of lines) {const url = line.trim(); if (url && !url.startsWith('#') && /\.(jpg|jpeg|png|gif|bmp|webp|svg)$/i.test(url)) {processImageUrl(url); processed = true; break;} }
                if (!processed) {console.log("URI List found, but no valid image URL detected:", uriList);}
            }
            if (!processed && dt.types.includes('text/html')) {
                const html = dt.getData('text/html');
                try {const tempDiv = document.createElement('div'); tempDiv.innerHTML = html; const imgElement = tempDiv.querySelector('img'); if (imgElement?.src) {processImageUrl(imgElement.src); processed = true;} else {console.log("HTML found, but no <img> tag with src detected:", html);} }
                catch (e) {console.error("Error parsing dropped HTML:", e);}
            }
            if (!processed) {
                addComment('Could not find a valid image file or URL in the dropped item.', 'error');
                resetFullPreview(); // Ensure UI resets if drop fails
            }
        }


        // --- Event Listeners Setup --- MODIFIED ---
        imageUpload.addEventListener('change', handleFileInputChange);
        iconFace.addEventListener('click', handleFaceIconClick);
        iconPose.addEventListener('click', handlePoseIconClick);
        iconGrid.addEventListener('click', handleGridIconClick);
        iconRestart.addEventListener('click', () => {if (currentImageElement || !imagePreviewContainer.classList.contains('hidden')) clearOverlays();});
        confirmGridButton.addEventListener('click', handleConfirmGrid);
        cancelModalButton.addEventListener('click', () => {addComment('Face selection cancelled.', 'info'); hideFaceSelectionModal(); selectedReferenceFaceIndex = null; redrawCanvas();});
        faceSelectionModal.addEventListener('click', (event) => {if (event.target === faceSelectionModal) {addComment('Face selection cancelled.', 'info'); hideFaceSelectionModal(); selectedReferenceFaceIndex = null; redrawCanvas();} });

        // External New Upload Button Listener
        newUploadButtonExt.addEventListener('click', () => {
            imageUpload.click(); // Trigger the hidden file input
        });

        // Canvas Listeners
        overlayCanvas.addEventListener('mousedown', handleMouseDown);
        overlayCanvas.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        overlayCanvas.addEventListener('touchstart', handleMouseDown, {passive: false});
        overlayCanvas.addEventListener('touchmove', handleMouseMove, {passive: false});
        window.addEventListener('touchend', handleMouseUp);
        window.addEventListener('touchcancel', handleMouseUp);

        // Body Drag/Drop Listeners
        bodyElement.addEventListener('dragover', handleDragOver);
        bodyElement.addEventListener('dragleave', handleDragLeave);
        bodyElement.addEventListener('drop', handleDrop);

        // Window Resize Listener
        let resizeTimeout; window.addEventListener('resize', () => {clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => {if (currentImageElement && !imagePreviewContainer.classList.contains('hidden')) {resizeCanvasToImage();} }, 150);});

        // --- Initial Page Load Setup ---
        initializeApp();

    </script>

</body>

</html>